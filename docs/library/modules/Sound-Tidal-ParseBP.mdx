---
name: Sound.Tidal.ParseBP
id: Sound.Tidal.ParseBP
---

### data
```
data TidalParseError 
```

### type
```
type MyParser = Parsec String Int 
```

### data
```
data TPat a where 
```

AST representation of patterns

### tShowList
```
tShowList :: Show a => [TPat a] -> String 
```

### tShow
```
tShow :: Show a => TPat a -> String 
```

### toPat
```
toPat :: (Parseable a, Enumerable a) => TPat a -> Pattern a 
```

### resolve_tpat
```
resolve_tpat :: (Enumerable a, Parseable a) => TPat a -> (Rational, Pattern a) 
```

### resolve_seq
```
resolve_seq :: (Enumerable a, Parseable a) => [TPat a] -> (Rational, Pattern a) 
```

### resolve_size
```
resolve_size :: [TPat a] -> [(Rational, TPat a)] 
```

### steps_tpat
```
steps_tpat :: Show a => TPat a -> (Rational, String) 
```

### steps_seq
```
steps_seq :: Show a => [TPat a] -> (Rational, String) 
```

### steps_size
```
steps_size :: Show a => [TPat a] -> [(Rational, String)] 
```

### parseBP
```
parseBP :: (Enumerable a, Parseable a) => String -> Either ParseError (Pattern a) 
```

### parseBP_E
```
parseBP_E :: (Enumerable a, Parseable a) => String -> Pattern a 
```

### parseTPat
```
parseTPat :: Parseable a => String -> Either ParseError (TPat a) 
```

### cP
```
cP :: (Enumerable a, Parseable a) => String -> Pattern a 
```

### class
```
class Parseable a where 
```

### class
```
class Enumerable a where 
```

### enumFromTo'
```
enumFromTo' :: (Ord a, Enum a) => a -> a -> Pattern a 
```

### enumFromThenTo'
```
enumFromThenTo' :: (Ord a, Enum a, Num a) => a -> a -> a -> Pattern a 
```

### type
```
type ColourD = Colour Double 
```

### lexer
```
lexer :: GenTokenParser String u Identity 
```

### braces
```
braces :: MyParser a -> MyParser a 
```

### brackets
```
brackets :: MyParser a -> MyParser a 
```

### parens
```
parens :: MyParser a -> MyParser a 
```

### angles
```
angles :: MyParser a -> MyParser a 
```

### symbol
```
symbol :: String -> MyParser String 
```

### natural
```
natural :: MyParser Integer 
```

### integer
```
integer :: MyParser Integer 
```

### decimal
```
decimal :: MyParser Integer 
```

### float
```
float :: MyParser Double 
```

### naturalOrFloat
```
naturalOrFloat :: MyParser (Either Integer Double) 
```

### data
```
data Sign 
```

### applySign
```
applySign :: Num a => Sign -> a -> a 
```

### sign
```
sign :: MyParser Sign 
```

### intOrFloat
```
intOrFloat :: MyParser Double 
```

### pSequence
```
pSequence :: Parseable a => MyParser (TPat a) -> MyParser (TPat a) 
```

### pRepeat
```
pRepeat :: TPat a -> MyParser (TPat a) 
```

### pElongate
```
pElongate :: TPat a -> MyParser (TPat a) 
```

### pSingle
```
pSingle :: MyParser (TPat a) -> MyParser (TPat a) 
```

### pVar
```
pVar :: MyParser (TPat a) 
```

### pPart
```
pPart :: Parseable a => MyParser (TPat a) -> MyParser (TPat a) 
```

### newSeed
```
newSeed :: MyParser Int 
```

### pPolyIn
```
pPolyIn :: Parseable a => MyParser (TPat a) -> MyParser (TPat a) 
```

### pPolyOut
```
pPolyOut :: Parseable a => MyParser (TPat a) -> MyParser (TPat a) 
```

### pCharNum
```
pCharNum :: MyParser Char 
```

### pString
```
pString :: MyParser String 
```

### wrapPos
```
wrapPos :: MyParser (TPat a) -> MyParser (TPat a) 
```

### pVocable
```
pVocable :: MyParser (TPat String) 
```

### pChar
```
pChar :: MyParser (TPat Char) 
```

### pDouble
```
pDouble :: MyParser (TPat Double) 
```

### pDoubleWithoutChord
```
pDoubleWithoutChord :: MyParser (TPat Double) 
```

### pNote
```
pNote :: MyParser (TPat Note) 
```

### pNoteWithoutChord
```
pNoteWithoutChord :: MyParser (TPat Note) 
```

### pBool
```
pBool :: MyParser (TPat Bool) 
```

### parseIntNote
```
parseIntNote :: Integral i => MyParser i 
```

### pIntegral
```
pIntegral :: (Integral a, Parseable a, Enumerable a) => MyParser (TPat a) 
```

### pIntegralWithoutChord
```
pIntegralWithoutChord :: (Integral a, Parseable a, Enumerable a) => MyParser (TPat a) 
```

### parseChord
```
parseChord :: (Enum a, Num a) => MyParser [a] 
```

### parseNote
```
parseNote :: Num a => MyParser a 
```

### fromNote
```
fromNote :: Num a => Pattern String -> Pattern a 
```

### pColour
```
pColour :: MyParser (TPat ColourD) 
```

### pMult
```
pMult :: TPat a -> MyParser (TPat a) 
```

### pRand
```
pRand :: TPat a -> MyParser (TPat a) 
```

### pE
```
pE :: TPat a -> MyParser (TPat a) 
```

### pRational
```
pRational :: MyParser (TPat Rational) 
```

### pRatio
```
pRatio :: MyParser Rational 
```

### pInteger
```
pInteger :: MyParser Double 
```

### pFloat
```
pFloat :: MyParser Double 
```

### pFraction
```
pFraction :: RealFrac a => a -> MyParser Rational 
```

### pRatioChar
```
pRatioChar :: Fractional a => MyParser a 
```

### pRatioSingleChar
```
pRatioSingleChar :: Fractional a => Char -> a -> MyParser a 
```

### isInt
```
isInt :: RealFrac a => a -> Bool 
```

### parseModInv
```
parseModInv :: MyParser Modifier 
```

### parseModInvNum
```
parseModInvNum :: MyParser [Modifier] 
```

### parseModDrop
```
parseModDrop :: MyParser [Modifier] 
```

### parseModOpen
```
parseModOpen :: MyParser Modifier 
```

### parseModRange
```
parseModRange :: MyParser Modifier 
```

### parseModifiers
```
parseModifiers :: MyParser [Modifier] 
```

### pModifiers
```
pModifiers :: MyParser (TPat [Modifier]) 
```

### pChord
```
pChord :: (Enum a, Num a, Parseable a, Enumerable a) => TPat a -> MyParser (TPat a) 
```

