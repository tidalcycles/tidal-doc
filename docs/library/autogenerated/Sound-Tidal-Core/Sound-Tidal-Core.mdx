---
title: Sound.Tidal.Core
slug: /library/modules/Sound.Tidal.Core
---

<!------------------------------------------------------------------------------
THIS IS A DOC FILE AUTOMATICALLY GENERATED FROM:

https://github.com/tidalcycles/Tidal/blob/main/src/Sound/Tidal/Core.hs

It's based on the documentation comments in the Tidal code.
Do not edit it directly--to update this documentation, please submit a
change to the original file in the Tidal repository. Thanks!
------------------------------------------------------------------------------->

## Elemental patterns
### sig
```
sig :: (Time -> a) -> Pattern a 
```

Takes a function from time to values, and turns it into a `Pattern`.

### sine
```
sine :: Fractional a => Pattern a 
```

`sine` - unipolar sinewave. A pattern of continuous values following a
 sinewave with frequency of one cycle, and amplitude from 0 to 1.

### sine2
```
sine2 :: Fractional a => Pattern a 
```

`sine2` - bipolar sinewave. A pattern of continuous values following a
 sinewave with frequency of one cycle, and amplitude from -1 to 1.

### cosine
```
cosine :: Fractional a => Pattern a 
```

`cosine` - unipolar cosine wave. A pattern of continuous values
 following a cosine with frequency of one cycle, and amplitude from
 0 to 1. Equivalent to `0.25 ~> sine`.

### cosine2
```
cosine2 :: Fractional a => Pattern a 
```

`cosine2` - bipolar cosine wave. A pattern of continuous values
 following a cosine with frequency of one cycle, and amplitude from
 -1 to 1. Equivalent to `0.25 ~> sine2`.

### saw
```
saw :: (Fractional a, Real a) => Pattern a 
```

`saw` - unipolar ascending sawtooth wave. A pattern of continuous values
 following a sawtooth with frequency of one cycle, and amplitude from
 0 to 1.

### saw2
```
saw2 :: (Fractional a, Real a) => Pattern a 
```

`saw2` - bipolar ascending sawtooth wave. A pattern of continuous values
 following a sawtooth with frequency of one cycle, and amplitude from
 -1 to 1.

### isaw
```
isaw :: (Fractional a, Real a) => Pattern a 
```

`isaw` like `saw`, but a descending (inverse) sawtooth.

### isaw2
```
isaw2 :: (Fractional a, Real a) => Pattern a 
```

`isaw2` like `saw2`, but a descending (inverse) sawtooth.

### tri
```
tri :: (Fractional a, Real a) => Pattern a 
```

`tri` - unipolar triangle wave. A pattern of continuous values
 following a triangle wave with frequency of one cycle, and amplitude from
 0 to 1.

### tri2
```
tri2 :: (Fractional a, Real a) => Pattern a 
```

`tri2` - bipolar triangle wave. A pattern of continuous values
 following a triangle wave with frequency of one cycle, and amplitude from
 -1 to 1.

### square
```
square :: Fractional a => Pattern a 
```

`square` - unipolar square wave. A pattern of continuous values
 following a square wave with frequency of one cycle, and amplitude from
 0 to 1.
 | `square` is like `sine`, for square waves.

### square2
```
square2 :: Fractional a => Pattern a 
```

`square2` - bipolar square wave. A pattern of continuous values
 following a square wave with frequency of one cycle, and amplitude from
 -1 to 1.

### envL
```
envL :: Pattern Double 
```

`envL` is a `Pattern` of continuous `Double` values, representing
 a linear interpolation between 0 and 1 during the first cycle, then
 staying constant at 1 for all following cycles. Possibly only
 useful if you're using something like the retrig function defined
 in tidal.el.

### envLR
```
envLR :: Pattern Double 
```

like `envL` but reversed.

### envEq
```
envEq :: Pattern Double 
```

'Equal power' version of `env`, for gain-based transitions

### envEqR
```
envEqR :: Pattern Double 
```

Equal power reversed

## Pattern algebra
### class
```
class Unionable a where 
```

### (|+|)
```
(|+|) :: (Applicative a, Num b) => a b -> a b -> a b 
```

### (|+)
```
(|+) :: Num a => Pattern a -> Pattern a -> Pattern a 
```

### (+|)
```
(+|) :: Num a => Pattern a -> Pattern a -> Pattern a 
```

### (||+)
```
(||+) :: Num a => Pattern a -> Pattern a -> Pattern a 
```

### (|++|)
```
(|++|) :: Applicative a => a String -> a String -> a String 
```

### (|++)
```
(|++) :: Pattern String -> Pattern String -> Pattern String 
```

### (++|)
```
(++|) :: Pattern String -> Pattern String -> Pattern String 
```

### (||++)
```
(||++) :: Pattern String -> Pattern String -> Pattern String 
```

### (|/|)
```
(|/|) :: (Applicative a, Fractional b) => a b -> a b -> a b 
```

### (|/)
```
(|/) :: Fractional a => Pattern a -> Pattern a -> Pattern a 
```

### (/|)
```
(/|) :: Fractional a => Pattern a -> Pattern a -> Pattern a 
```

### (||/)
```
(||/) :: Fractional a => Pattern a -> Pattern a -> Pattern a 
```

### (|*|)
```
(|*|) :: (Applicative a, Num b) => a b -> a b -> a b 
```

### (|*)
```
(|*) :: Num a => Pattern a -> Pattern a -> Pattern a 
```

### (*|)
```
(*|) :: Num a => Pattern a -> Pattern a -> Pattern a 
```

### (||*)
```
(||*) :: Num a => Pattern a -> Pattern a -> Pattern a 
```

### (|-|)
```
(|-|) :: (Applicative a, Num b) => a b -> a b -> a b 
```

### (|-)
```
(|-) :: Num a => Pattern a -> Pattern a -> Pattern a 
```

### (-|)
```
(-|) :: Num a => Pattern a -> Pattern a -> Pattern a 
```

### (||-)
```
(||-) :: Num a => Pattern a -> Pattern a -> Pattern a 
```

### (|%|)
```
(|%|) :: (Applicative a, Moddable b) => a b -> a b -> a b 
```

### (|%)
```
(|%) :: Moddable a => Pattern a -> Pattern a -> Pattern a 
```

### (%|)
```
(%|) :: Moddable a => Pattern a -> Pattern a -> Pattern a 
```

### (||%)
```
(||%) :: Moddable a => Pattern a -> Pattern a -> Pattern a 
```

### (|**|)
```
(|**|) :: (Applicative a, Floating b) => a b -> a b -> a b 
```

### (|**)
```
(|**) :: Floating a => Pattern a -> Pattern a -> Pattern a 
```

### (**|)
```
(**|) :: Floating a => Pattern a -> Pattern a -> Pattern a 
```

### (||**)
```
(||**) :: Floating a => Pattern a -> Pattern a -> Pattern a 
```

### (|>|)
```
(|>|) :: (Applicative a, Unionable b) => a b -> a b -> a b 
```

### (|>)
```
(|>) :: Unionable a => Pattern a -> Pattern a -> Pattern a 
```

### (>|)
```
(>|) :: Unionable a => Pattern a -> Pattern a -> Pattern a 
```

### (||>)
```
(||>) :: Unionable a => Pattern a -> Pattern a -> Pattern a 
```

### (|<|)
```
(|<|) :: (Applicative a, Unionable b) => a b -> a b -> a b 
```

### (|<)
```
(|<) :: Unionable a => Pattern a -> Pattern a -> Pattern a 
```

### (<|)
```
(<|) :: Unionable a => Pattern a -> Pattern a -> Pattern a 
```

### (||<)
```
(||<) :: Unionable a => Pattern a -> Pattern a -> Pattern a 
```

### (#)
```
(#) :: Unionable b => Pattern b -> Pattern b -> Pattern b 
```

## Constructing patterns
### fromList
```
fromList :: [a] -> Pattern a 
```

Turns a list of values into a pattern, playing one of them per cycle.

### fastFromList
```
fastFromList :: [a] -> Pattern a 
```

Turns a list of values into a pattern, playing all of them per cycle.

### listToPat
```
listToPat :: [a] -> Pattern a 
```

A synonym for `fastFromList`

### fromMaybes
```
fromMaybes :: [Maybe a] -> Pattern a 
```

'fromMaybes; is similar to `fromList`, but allows values to
 be optional using the `Maybe` type, so that `Nothing` results in
 gaps in the pattern.

### run
```
run :: (Enum a, Num a) => Pattern a -> Pattern a 
```

A pattern of whole numbers from 0 to the given number, in a single cycle.

### _run
```
_run :: (Enum a, Num a) => a -> Pattern a 
```

### scan
```
scan :: (Enum a, Num a) => Pattern a -> Pattern a 
```

From `1` for the first cycle, successively adds a number until it gets up to `n`

### _scan
```
_scan :: (Enum a, Num a) => a -> Pattern a 
```

## Combining patterns
### append
```
append :: Pattern a -> Pattern a -> Pattern a 
```

Alternate between cycles of the two given patterns

### cat
```
cat :: [Pattern a] -> Pattern a 
```

Like `append`, but for a list of patterns. Interlaces them, playing the first cycle from each
 in turn, then the second cycle from each, and so on.

### slowCat
```
slowCat :: [Pattern a] -> Pattern a 
```

Alias for `cat`

### slowcat
```
slowcat :: [Pattern a] -> Pattern a 
```

### slowAppend
```
slowAppend :: Pattern a -> Pattern a -> Pattern a 
```

Alias for `append`

### slowappend
```
slowappend :: Pattern a -> Pattern a -> Pattern a 
```

### fastAppend
```
fastAppend :: Pattern a -> Pattern a -> Pattern a 
```

Like `append`, but twice as fast

### fastappend
```
fastappend :: Pattern a -> Pattern a -> Pattern a 
```

### fastCat
```
fastCat :: [Pattern a] -> Pattern a 
```

The same as `cat`, but speeds up the result by the number of
 patterns there are, so the cycles from each are squashed to fit a
 single cycle.

### fastcat
```
fastcat :: [Pattern a] -> Pattern a 
```

Alias for `fastCat`

### timeCat
```
timeCat :: [(Time, Pattern a)] -> Pattern a 
```

Similar to `fastCat`, but each pattern is given a relative duration

### timecat
```
timecat :: [(Time, Pattern a)] -> Pattern a 
```

Alias for `timeCat`

### overlay
```
overlay :: Pattern a -> Pattern a -> Pattern a 
```

`overlay` combines two `Pattern`s into a new pattern, so that
 their events are combined over time. 

### stack
```
stack :: [Pattern a] -> Pattern a 
```

`stack` combines a list of `Pattern`s into a new pattern, so that
 their events are combined over time.

## Manipulating time
### (<~)
```
(<~) :: Pattern Time -> Pattern a -> Pattern a 
```

Shifts a pattern back in time by the given amount, expressed in cycles

### (~>)
```
(~>) :: Pattern Time -> Pattern a -> Pattern a 
```

Shifts a pattern forward in time by the given amount, expressed in cycles

### slowSqueeze
```
slowSqueeze :: Pattern Time -> Pattern a -> Pattern a 
```

Slow down a pattern by the factors in the given time pattern, `squeezing`
 the pattern to fit the slot given in the time pattern

### sparsity
```
sparsity :: Pattern Time -> Pattern a -> Pattern a 
```

An alias for `slow`

### zoom
```
zoom :: (Time, Time) -> Pattern a -> Pattern a 
```

Plays a portion of a pattern, specified by a time arc (start and end time).
The new resulting pattern is played over the time period of the original pattern:

```haskell
d1 $ zoom (0.25, 0.75) $ sound "bd*2 hh*3 [sn bd]*2 drum"
```
In the pattern above, `zoom` is used with an arc from 25% to 75%. It is equivalent to this pattern:

```haskell
d1 $ sound "hh*3 [sn bd]*2"
```
### zoomArc
```
zoomArc :: Arc -> Pattern a -> Pattern a 
```

### fastGap
```
fastGap :: Pattern Time -> Pattern a -> Pattern a 
```

`fastGap` is similar to `fast` but maintains its cyclic
 alignment. For example, `fastGap 2 p` would squash the events in
 pattern `p` into the first half of each cycle (and the second
 halves would be empty). The factor should be at least 1

### densityGap
```
densityGap :: Pattern Time -> Pattern a -> Pattern a 
```

An alias for `fastGap`

### compress
```
compress :: (Time, Time) -> Pattern a -> Pattern a 
```

### compressTo
```
compressTo :: (Time, Time) -> Pattern a -> Pattern a 
```

### repeatCycles
```
repeatCycles :: Pattern Int -> Pattern a -> Pattern a 
```

### _repeatCycles
```
_repeatCycles :: Int -> Pattern a -> Pattern a 
```

### fastRepeatCycles
```
fastRepeatCycles :: Int -> Pattern a -> Pattern a 
```

### every
```
every :: Pattern Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a 
```

Functions which work on other functions (higher order functions)

`every n f p` applies the function `f` to `p`, but only affects
 every `n` cycles.

### _every
```
_every :: Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a 
```

### every'
```
every' :: Pattern Int -> Pattern Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a 
```

`every n o f'` is like `every n f` with an offset of `o` cycles

### _every'
```
_every' :: Int -> Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a 
```

### foldEvery
```
foldEvery :: [Int] -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a 
```

`foldEvery ns f p` applies the function `f` to `p`, and is applied for
 each cycle in `ns`.

### when
```
when :: (Int -> Bool) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a 
```

Only `when` the given test function returns `True` the given pattern
transformation is applied. The test function will be called with the
current cycle as a number.

```haskell
d1 $ when ((elem '4').show)
  (striate 4)
  $ sound "hh hc"
```
The above will only apply `striate 4` to the pattern if the current
cycle number contains the number 4. So the fourth cycle will be
striated and the fourteenth and so on. Expect lots of striates after
cycle number 399.

### whenT
```
whenT :: (Time -> Bool) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a 
```

Like `when`, but works on continuous time values rather than cycle numbers.

### _getP_
```
_getP_ :: (Value -> Maybe a) -> Pattern Value -> Pattern a 
```

### _getP
```
_getP :: a -> (Value -> Maybe a) -> Pattern Value -> Pattern a 
```

### _cX
```
_cX :: a -> (Value -> Maybe a) -> String -> Pattern a 
```

### _cX_
```
_cX_ :: (Value -> Maybe a) -> String -> Pattern a 
```

### cF
```
cF :: Double -> String -> Pattern Double 
```

### cF_
```
cF_ :: String -> Pattern Double 
```

### cF0
```
cF0 :: String -> Pattern Double 
```

### cN
```
cN :: Note -> String -> Pattern Note 
```

### cN_
```
cN_ :: String -> Pattern Note 
```

### cN0
```
cN0 :: String -> Pattern Note 
```

### cI
```
cI :: Int -> String -> Pattern Int 
```

### cI_
```
cI_ :: String -> Pattern Int 
```

### cI0
```
cI0 :: String -> Pattern Int 
```

### cB
```
cB :: Bool -> String -> Pattern Bool 
```

### cB_
```
cB_ :: String -> Pattern Bool 
```

### cB0
```
cB0 :: String -> Pattern Bool 
```

### cR
```
cR :: Rational -> String -> Pattern Rational 
```

### cR_
```
cR_ :: String -> Pattern Rational 
```

### cR0
```
cR0 :: String -> Pattern Rational 
```

### cT
```
cT :: Time -> String -> Pattern Time 
```

### cT0
```
cT0 :: String -> Pattern Time 
```

### cT_
```
cT_ :: String -> Pattern Time 
```

### cS
```
cS :: String -> String -> Pattern String 
```

### cS_
```
cS_ :: String -> Pattern String 
```

### cS0
```
cS0 :: String -> Pattern String 
```

### in0
```
in0 :: Pattern Double 
```

### in1
```
in1 :: Pattern Double 
```

### in2
```
in2 :: Pattern Double 
```

### in3
```
in3 :: Pattern Double 
```

### in4
```
in4 :: Pattern Double 
```

### in5
```
in5 :: Pattern Double 
```

### in6
```
in6 :: Pattern Double 
```

### in7
```
in7 :: Pattern Double 
```

### in8
```
in8 :: Pattern Double 
```

### in9
```
in9 :: Pattern Double 
```

### in10
```
in10 :: Pattern Double 
```

### in11
```
in11 :: Pattern Double 
```

### in12
```
in12 :: Pattern Double 
```

### in13
```
in13 :: Pattern Double 
```

### in14
```
in14 :: Pattern Double 
```

### in15
```
in15 :: Pattern Double 
```

### in16
```
in16 :: Pattern Double 
```

### in17
```
in17 :: Pattern Double 
```

### in18
```
in18 :: Pattern Double 
```

### in19
```
in19 :: Pattern Double 
```

### in20
```
in20 :: Pattern Double 
```

### in21
```
in21 :: Pattern Double 
```

### in22
```
in22 :: Pattern Double 
```

### in23
```
in23 :: Pattern Double 
```

### in24
```
in24 :: Pattern Double 
```

### in25
```
in25 :: Pattern Double 
```

### in26
```
in26 :: Pattern Double 
```

### in27
```
in27 :: Pattern Double 
```

### in28
```
in28 :: Pattern Double 
```

### in29
```
in29 :: Pattern Double 
```

### in30
```
in30 :: Pattern Double 
```

### in31
```
in31 :: Pattern Double 
```

### in32
```
in32 :: Pattern Double 
```

### in33
```
in33 :: Pattern Double 
```

### in34
```
in34 :: Pattern Double 
```

### in35
```
in35 :: Pattern Double 
```

### in36
```
in36 :: Pattern Double 
```

### in37
```
in37 :: Pattern Double 
```

### in38
```
in38 :: Pattern Double 
```

### in39
```
in39 :: Pattern Double 
```

### in40
```
in40 :: Pattern Double 
```

### in41
```
in41 :: Pattern Double 
```

### in42
```
in42 :: Pattern Double 
```

### in43
```
in43 :: Pattern Double 
```

### in44
```
in44 :: Pattern Double 
```

### in45
```
in45 :: Pattern Double 
```

### in46
```
in46 :: Pattern Double 
```

### in47
```
in47 :: Pattern Double 
```

### in48
```
in48 :: Pattern Double 
```

### in49
```
in49 :: Pattern Double 
```

### in50
```
in50 :: Pattern Double 
```

### in51
```
in51 :: Pattern Double 
```

### in52
```
in52 :: Pattern Double 
```

### in53
```
in53 :: Pattern Double 
```

### in54
```
in54 :: Pattern Double 
```

### in55
```
in55 :: Pattern Double 
```

### in56
```
in56 :: Pattern Double 
```

### in57
```
in57 :: Pattern Double 
```

### in58
```
in58 :: Pattern Double 
```

### in59
```
in59 :: Pattern Double 
```

### in60
```
in60 :: Pattern Double 
```

### in61
```
in61 :: Pattern Double 
```

### in62
```
in62 :: Pattern Double 
```

### in63
```
in63 :: Pattern Double 
```

### in64
```
in64 :: Pattern Double 
```

### in65
```
in65 :: Pattern Double 
```

### in66
```
in66 :: Pattern Double 
```

### in67
```
in67 :: Pattern Double 
```

### in68
```
in68 :: Pattern Double 
```

### in69
```
in69 :: Pattern Double 
```

### in70
```
in70 :: Pattern Double 
```

### in71
```
in71 :: Pattern Double 
```

### in72
```
in72 :: Pattern Double 
```

### in73
```
in73 :: Pattern Double 
```

### in74
```
in74 :: Pattern Double 
```

### in75
```
in75 :: Pattern Double 
```

### in76
```
in76 :: Pattern Double 
```

### in77
```
in77 :: Pattern Double 
```

### in78
```
in78 :: Pattern Double 
```

### in79
```
in79 :: Pattern Double 
```

### in80
```
in80 :: Pattern Double 
```

### in81
```
in81 :: Pattern Double 
```

### in82
```
in82 :: Pattern Double 
```

### in83
```
in83 :: Pattern Double 
```

### in84
```
in84 :: Pattern Double 
```

### in85
```
in85 :: Pattern Double 
```

### in86
```
in86 :: Pattern Double 
```

### in87
```
in87 :: Pattern Double 
```

### in88
```
in88 :: Pattern Double 
```

### in89
```
in89 :: Pattern Double 
```

### in90
```
in90 :: Pattern Double 
```

### in91
```
in91 :: Pattern Double 
```

### in92
```
in92 :: Pattern Double 
```

### in93
```
in93 :: Pattern Double 
```

### in94
```
in94 :: Pattern Double 
```

### in95
```
in95 :: Pattern Double 
```

### in96
```
in96 :: Pattern Double 
```

### in97
```
in97 :: Pattern Double 
```

### in98
```
in98 :: Pattern Double 
```

### in99
```
in99 :: Pattern Double 
```

### in100
```
in100 :: Pattern Double 
```

### in101
```
in101 :: Pattern Double 
```

### in102
```
in102 :: Pattern Double 
```

### in103
```
in103 :: Pattern Double 
```

### in104
```
in104 :: Pattern Double 
```

### in105
```
in105 :: Pattern Double 
```

### in106
```
in106 :: Pattern Double 
```

### in107
```
in107 :: Pattern Double 
```

### in108
```
in108 :: Pattern Double 
```

### in109
```
in109 :: Pattern Double 
```

### in110
```
in110 :: Pattern Double 
```

### in111
```
in111 :: Pattern Double 
```

### in112
```
in112 :: Pattern Double 
```

### in113
```
in113 :: Pattern Double 
```

### in114
```
in114 :: Pattern Double 
```

### in115
```
in115 :: Pattern Double 
```

### in116
```
in116 :: Pattern Double 
```

### in117
```
in117 :: Pattern Double 
```

### in118
```
in118 :: Pattern Double 
```

### in119
```
in119 :: Pattern Double 
```

### in120
```
in120 :: Pattern Double 
```

### in121
```
in121 :: Pattern Double 
```

### in122
```
in122 :: Pattern Double 
```

### in123
```
in123 :: Pattern Double 
```

### in124
```
in124 :: Pattern Double 
```

### in125
```
in125 :: Pattern Double 
```

### in126
```
in126 :: Pattern Double 
```

### in127
```
in127 :: Pattern Double 
```

