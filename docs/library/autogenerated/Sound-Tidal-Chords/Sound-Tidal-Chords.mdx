---
title: Sound.Tidal.Chords
slug: /library/modules/Sound.Tidal.Chords
---

<!------------------------------------------------------------------------------
THIS IS A DOC FILE AUTOMATICALLY GENERATED FROM:

https://github.com/tidalcycles/Tidal/blob/main/src/Sound/Tidal/Chords.hs

It's based on the documentation comments in the Tidal code.
Do not edit it directly--to update this documentation, please submit a
change to the original file in the Tidal repository. Thanks!
------------------------------------------------------------------------------->

### major
```
major :: Num a => [a] 
```

### aug
```
aug :: Num a => [a] 
```

### six
```
six :: Num a => [a] 
```

### sixNine
```
sixNine :: Num a => [a] 
```

### major7
```
major7 :: Num a => [a] 
```

### major9
```
major9 :: Num a => [a] 
```

### add9
```
add9 :: Num a => [a] 
```

### major11
```
major11 :: Num a => [a] 
```

### add11
```
add11 :: Num a => [a] 
```

### major13
```
major13 :: Num a => [a] 
```

### add13
```
add13 :: Num a => [a] 
```

### dom7
```
dom7 :: Num a => [a] 
```

### dom9
```
dom9 :: Num a => [a] 
```

### dom11
```
dom11 :: Num a => [a] 
```

### dom13
```
dom13 :: Num a => [a] 
```

### sevenFlat5
```
sevenFlat5 :: Num a => [a] 
```

### sevenSharp5
```
sevenSharp5 :: Num a => [a] 
```

### sevenFlat9
```
sevenFlat9 :: Num a => [a] 
```

### nine
```
nine :: Num a => [a] 
```

### eleven
```
eleven :: Num a => [a] 
```

### thirteen
```
thirteen :: Num a => [a] 
```

### minor
```
minor :: Num a => [a] 
```

### diminished
```
diminished :: Num a => [a] 
```

### minorSharp5
```
minorSharp5 :: Num a => [a] 
```

### minor6
```
minor6 :: Num a => [a] 
```

### minorSixNine
```
minorSixNine :: Num a => [a] 
```

### minor7flat5
```
minor7flat5 :: Num a => [a] 
```

### minor7
```
minor7 :: Num a => [a] 
```

### minor7sharp5
```
minor7sharp5 :: Num a => [a] 
```

### minor7flat9
```
minor7flat9 :: Num a => [a] 
```

### minor7sharp9
```
minor7sharp9 :: Num a => [a] 
```

### diminished7
```
diminished7 :: Num a => [a] 
```

### minor9
```
minor9 :: Num a => [a] 
```

### minor11
```
minor11 :: Num a => [a] 
```

### minor13
```
minor13 :: Num a => [a] 
```

### one
```
one :: Num a => [a] 
```

### five
```
five :: Num a => [a] 
```

### sus2
```
sus2 :: Num a => [a] 
```

### sus4
```
sus4 :: Num a => [a] 
```

### sevenSus2
```
sevenSus2 :: Num a => [a] 
```

### sevenSus4
```
sevenSus4 :: Num a => [a] 
```

### nineSus4
```
nineSus4 :: Num a => [a] 
```

### sevenFlat10
```
sevenFlat10 :: Num a => [a] 
```

### nineSharp5
```
nineSharp5 :: Num a => [a] 
```

### minor9sharp5
```
minor9sharp5 :: Num a => [a] 
```

### sevenSharp5flat9
```
sevenSharp5flat9 :: Num a => [a] 
```

### minor7sharp5flat9
```
minor7sharp5flat9 :: Num a => [a] 
```

### elevenSharp
```
elevenSharp :: Num a => [a] 
```

### minor11sharp
```
minor11sharp :: Num a => [a] 
```

### chordTable
```
chordTable :: Num a => [(String, [a])] 
```

`chordate cs m n` selects the `n`th "chord" (a chord is a list of Ints)
 from a list of chords `cs` and transposes it by `m`
 chordate :: Num b => [[b]] -> b -> Int -> [b]
 chordate cs m n = map (+m) $ cs!!n

`enchord chords pn pc` turns every note in the note pattern `pn` into
 a chord, selecting from the chord lists `chords` using the index pattern
 `pc`.  For example, `Chords.enchord [Chords.major Chords.minor] "c g" "0 1"`
 will create a pattern of a C-major chord followed by a G-minor chord.
 enchord :: Num a => [[a]] -> Pattern a -> Pattern Int -> Pattern a
 enchord chords pn pc = flatpat $ (chordate chords) $ pn * pc

### chordL
```
chordL :: Num a => Pattern String -> Pattern [a] 
```

### chordList
```
chordList :: String 
```

### data
```
data Modifier 
```

### applyModifier
```
applyModifier :: (Enum a, Num a) => Modifier -> [a] -> [a] 
```

### applyModifierPat
```
applyModifierPat :: (Num a, Enum a) => Pattern [a] -> Pattern [Modifier] -> Pattern [a] 
```

### applyModifierPatSeq
```
applyModifierPatSeq :: (Num a, Enum a) => (a -> b) -> Pattern [a] -> [Pattern [Modifier]] -> Pattern [b] 
```

### chordToPatSeq
```
chordToPatSeq :: (Num a, Enum a) => (a -> b) -> Pattern a -> Pattern String -> [Pattern [Modifier]] -> Pattern b 
```

### chord
```
chord :: (Num a, Enum a) => Pattern a -> Pattern String -> [Pattern [Modifier]] -> Pattern a 
```

turns a given pattern of some Num type, a pattern of chord names and a list of patterns of modifiers into a chord pattern

