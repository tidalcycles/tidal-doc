---
title: Sound.Tidal.Pattern
slug: /library/modules/Sound.Tidal.Pattern
---

<!------------------------------------------------------------------------------
THIS IS A DOC FILE AUTOMATICALLY GENERATED FROM:

https://github.com/tidalcycles/Tidal/blob/main/src/Sound/Tidal/Pattern.hs

It's based on the documentation comments in the Tidal code.
Do not edit it directly--to update this documentation, please submit a
change to the original file in the Tidal repository. Thanks!
------------------------------------------------------------------------------->

### type
```
type Event a = EventF (ArcF Time) a 
```

### data
```
data State 
```

an Arc and some named control values

### data
```
data Pattern a 
```

A datatype representing events taking place over time

### data
```
data Context 
```

Some context for an event, currently just position within sourcecode

### type
```
type ControlPattern = Pattern ValueMap 
```

### type
```
type ValueMap = Map String Value 
```

### class
```
class Moddable a where 
```

### newtype
```
newtype Note 
```

Note is Double, but with a different parser

### data
```
data Value 
```

Polymorphic values

### class
```
class Stringy a where 
```

### data
```
data EventF a b 
```

An event is a value that's active during a timespan. If a whole
 is present, the part should be equal to or fit inside it.

### class
```
class Valuable a where 
```

### (*>)
```
(*>) :: Pattern (a -> b) -> Pattern a -> Pattern b infixl 4 
```

Like *, but the `wholes` come from the right

### empty
```
empty :: Pattern a 
```

### (<*)
```
(<*) :: Pattern (a -> b) -> Pattern a -> Pattern b infixl 4 
```

Like *, but the `wholes` come from the left

### silence
```
silence :: Pattern a 
```

### rev
```
rev :: Pattern a -> Pattern a 
```

`rev p` returns `p` with the event positions in each cycle
 reversed (or mirrored).

### noOv
```
noOv :: String -> a 
```

### applyPatToPatBoth
```
applyPatToPatBoth :: Pattern (a -> b) -> Pattern a -> Pattern b 
```

### applyPatToPatLeft
```
applyPatToPatLeft :: Pattern (a -> b) -> Pattern a -> Pattern b 
```

### applyPatToPatRight
```
applyPatToPatRight :: Pattern (a -> b) -> Pattern a -> Pattern b 
```

### (<<*)
```
(<<*) :: Pattern (a -> b) -> Pattern a -> Pattern b infixl 4 
```

Like *, but the `wholes` come from the left

### applyPatToPatSqueeze
```
applyPatToPatSqueeze :: Pattern (a -> b) -> Pattern a -> Pattern b 
```

### applyPatToPat
```
applyPatToPat :: (Maybe Arc -> Maybe Arc -> Maybe (Maybe Arc)) -> Pattern (a -> b) -> Pattern a -> Pattern b 
```

### wholeOrPart
```
wholeOrPart :: Event a -> Arc 
```

### filterAnalog
```
filterAnalog :: Pattern a -> Pattern a 
```

### filterDigital
```
filterDigital :: Pattern a -> Pattern a 
```

### combineContexts
```
combineContexts :: [Context] -> Context 
```

### squeezeJoin
```
squeezeJoin :: Pattern (Pattern a) -> Pattern a 
```

Like `unwrap`, but cycles of the inner patterns are compressed to fit the
 timespan of the outer whole (or the original query if it's a continuous pattern?)
 TODO - what if a continuous pattern contains a discrete one, or vice-versa?

### unwrap
```
unwrap :: Pattern (Pattern a) -> Pattern a 
```

Turns a pattern of patterns into a single pattern.
 (this is actually `join`)

1/ For query `arc`, get the events from the outer pattern `pp`
 2/ Query the inner pattern using the `part` of the outer
 3/ For each inner event, set the whole and part to be the intersection
    of the outer whole and part, respectively
 4 Concatenate all the events together (discarding wholesparts that didn't intersect)

TODO - what if a continuous pattern contains a discrete one, or vice-versa?

### innerJoin
```
innerJoin :: Pattern (Pattern a) -> Pattern a 
```

Turns a pattern of patterns into a single pattern. Like `unwrap`,
 but structure only comes from the inner pattern.

### outerJoin
```
outerJoin :: Pattern (Pattern a) -> Pattern a 
```

Turns a pattern of patterns into a single pattern. Like `unwrap`,
 but structure only comes from the outer pattern.

### focusArc
```
focusArc :: Arc -> Pattern a -> Pattern a 
```

### applyFIS
```
applyFIS :: (Double -> Double) -> (Int -> Int) -> (String -> String) -> Value -> Value 
```

General utilities..

Apply one of three functions to a Value, depending on its type

### fNum2
```
fNum2 :: (Int -> Int -> Int) -> (Double -> Double -> Double) -> Value -> Value -> Value 
```

Apply one of two functions to a pair of Values, depending on their types (int
 or float; strings and rationals are ignored)

### queryArc
```
queryArc :: Pattern a -> Arc -> [Event a] 
```

### splitQueries
```
splitQueries :: Pattern a -> Pattern a 
```

Splits queries that span cycles. For example `query p (0.5, 1.5)` would be
 turned into two queries, `(0.5,1)` and `(1,1.5)`, and the results
 combined. Being able to assume queries don't span cycles often
 makes transformations easier to specify.

### withResultArc
```
withResultArc :: (Arc -> Arc) -> Pattern a -> Pattern a 
```

Apply a function to the arcs/timespans (both whole and parts) of the result

### withResultTime
```
withResultTime :: (Time -> Time) -> Pattern a -> Pattern a 
```

Apply a function to the time (both start and end of the timespans
 of both whole and parts) of the result

### withQueryArc
```
withQueryArc :: (Arc -> Arc) -> Pattern a -> Pattern a 
```

Apply a function to the timespan of the query

### withQueryTime
```
withQueryTime :: (Time -> Time) -> Pattern a -> Pattern a 
```

Apply a function to the time (both start and end) of the query

### withQueryControls
```
withQueryControls :: (ValueMap -> ValueMap) -> Pattern a -> Pattern a 
```

Apply a function to the control values of the query

### withEvent
```
withEvent :: (Event a -> Event b) -> Pattern a -> Pattern b 
```

`withEvent f p` returns a new `Pattern` with each event mapped over
 function `f`.

### withValue
```
withValue :: (a -> b) -> Pattern a -> Pattern b 
```

`withEvent f p` returns a new `Pattern` with each value mapped over
 function `f`.

### withEvents
```
withEvents :: ([Event a] -> [Event b]) -> Pattern a -> Pattern b 
```

`withEvent f p` returns a new `Pattern` with f applied to the resulting list of events for each query
 function `f`.

### withPart
```
withPart :: (Arc -> Arc) -> Pattern a -> Pattern a 
```

`withPart f p` returns a new `Pattern` with function `f` applied
 to the part.

### _extract
```
_extract :: (Value -> Maybe a) -> String -> ControlPattern -> Pattern a 
```

### filterJust
```
filterJust :: Pattern (Maybe a) -> Pattern a 
```

Turns a pattern of `Maybe` values into a pattern of values,
 dropping the events of `Nothing`.

### extractI
```
extractI :: String -> ControlPattern -> Pattern Int 
```

Extract a pattern of integer values by from a control pattern, given the name of the control

### getI
```
getI :: Value -> Maybe Int 
```

### extractF
```
extractF :: String -> ControlPattern -> Pattern Double 
```

Extract a pattern of floating point values by from a control pattern, given the name of the control

### getF
```
getF :: Value -> Maybe Double 
```

### extractS
```
extractS :: String -> ControlPattern -> Pattern String 
```

Extract a pattern of string values by from a control pattern, given the name of the control

### getS
```
getS :: Value -> Maybe String 
```

### extractB
```
extractB :: String -> ControlPattern -> Pattern Bool 
```

Extract a pattern of boolean values by from a control pattern, given the name of the control

### getB
```
getB :: Value -> Maybe Bool 
```

### extractR
```
extractR :: String -> ControlPattern -> Pattern Rational 
```

Extract a pattern of rational values by from a control pattern, given the name of the control

### getR
```
getR :: Value -> Maybe Rational 
```

### compressArc
```
compressArc :: Arc -> Pattern a -> Pattern a 
```

### rotR
```
rotR :: Time -> Pattern a -> Pattern a 
```

Shifts a pattern forward in time by the given amount, expressed in cycles

### _fastGap
```
_fastGap :: Time -> Pattern a -> Pattern a 
```

### compressArcTo
```
compressArcTo :: Arc -> Pattern a -> Pattern a 
```

### _fast
```
_fast :: Time -> Pattern a -> Pattern a 
```

### fast
```
fast :: Pattern Time -> Pattern a -> Pattern a 
```

Speed up a pattern by the given time pattern

### tParam
```
tParam :: (t1 -> t2 -> Pattern a) -> Pattern t1 -> t2 -> Pattern a 
```

### fastSqueeze
```
fastSqueeze :: Pattern Time -> Pattern a -> Pattern a 
```

Slow down a pattern by the factors in the given time pattern, `squeezing`
 the pattern to fit the slot given in the time pattern

### tParamSqueeze
```
tParamSqueeze :: (a -> Pattern b -> Pattern c) -> Pattern a -> Pattern b -> Pattern c 
```

### density
```
density :: Pattern Time -> Pattern a -> Pattern a 
```

An alias for `fast`

### slow
```
slow :: Pattern Time -> Pattern a -> Pattern a 
```

Slow down a pattern by the given time pattern

### _slow
```
_slow :: Time -> Pattern a -> Pattern a 
```

### rotL
```
rotL :: Time -> Pattern a -> Pattern a 
```

Shifts a pattern back in time by the given amount, expressed in cycles

### matchManyToOne
```
matchManyToOne :: (b -> a -> Bool) -> Pattern a -> Pattern b -> Pattern (Bool, b) 
```

Mark values in the first pattern which match with at least one
 value in the second pattern.

### filterValues
```
filterValues :: (a -> Bool) -> Pattern a -> Pattern a 
```

Remove events from patterns that to not meet the given test

### filterWhen
```
filterWhen :: (Time -> Bool) -> Pattern a -> Pattern a 
```

### wholeStart
```
wholeStart :: Event a -> Time 
```

Get the onset of an event's `whole`

### filterOnsets
```
filterOnsets :: Pattern a -> Pattern a 
```

### eventPartStart
```
eventPartStart :: Event a -> Time 
```

Get the onset of an event's `whole`

### filterEvents
```
filterEvents :: (Event a -> Bool) -> Pattern a -> Pattern a 
```

### isDigital
```
isDigital :: Event a -> Bool 
```

### isAnalog
```
isAnalog :: Event a -> Bool 
```

### playFor
```
playFor :: Time -> Time -> Pattern a -> Pattern a 
```

### tParam2
```
tParam2 :: (a -> b -> c -> Pattern d) -> Pattern a -> Pattern b -> c -> Pattern d 
```

### tParam3
```
tParam3 :: (a -> b -> c -> Pattern d -> Pattern e) -> Pattern a -> Pattern b -> Pattern c -> Pattern d -> Pattern e 
```

### setContext
```
setContext :: Context -> Pattern a -> Pattern a 
```

### withContext
```
withContext :: (Context -> Context) -> Pattern a -> Pattern a 
```

### deltaMini
```
deltaMini :: String -> String 
```

### onsetIn
```
onsetIn :: Arc -> Event a -> Bool 
```

`True` if an `EventF`'s starts is within given `ArcF`

### defragParts
```
defragParts :: Eq a => [Event a] -> [Event a] 
```

Returns a list of events, with any adjacent parts of the same whole combined

### isAdjacent
```
isAdjacent :: Eq a => Event a -> Event a -> Bool 
```

Returns `True` if the two given events are adjacent parts of the same whole

### wholeStop
```
wholeStop :: Event a -> Time 
```

Get the offset of an event's `whole`

### eventPartStop
```
eventPartStop :: Event a -> Time 
```

Get the offset of an event's `part`

### eventPart
```
eventPart :: Event a -> Arc 
```

Get the timespan of an event's `part`

### eventValue
```
eventValue :: Event a -> a 
```

### eventHasOnset
```
eventHasOnset :: Event a -> Bool 
```

### toEvent
```
toEvent :: (((Time, Time), (Time, Time)), a) -> Event a 
```

### resolveState
```
resolveState :: ValueMap -> [Event ValueMap] -> (ValueMap, [Event ValueMap]) 
```

### getN
```
getN :: Value -> Maybe Note 
```

### getBlob
```
getBlob :: Value -> Maybe [Word8] 
```

### getList
```
getList :: Value -> Maybe [Value] 
```

### valueToPattern
```
valueToPattern :: Value -> Pattern Value 
```

### sameDur
```
sameDur :: Event a -> Event a -> Bool 
```

### groupEventsBy
```
groupEventsBy :: Eq a => (Event a -> Event a -> Bool) -> [Event a] -> [[Event a]] 
```

### collectEvent
```
collectEvent :: [Event a] -> Maybe (Event [a]) 
```

### collectEventsBy
```
collectEventsBy :: Eq a => (Event a -> Event a -> Bool) -> [Event a] -> [Event [a]] 
```

### collectBy
```
collectBy :: Eq a => (Event a -> Event a -> Bool) -> Pattern a -> Pattern [a] 
```

collects all events satisfying the same constraint into a list

### collect
```
collect :: Eq a => Pattern a -> Pattern [a] 
```

collects all events occuring at the exact same time into a list

### uncollectEvent
```
uncollectEvent :: Event [a] -> [Event a] 
```

### uncollectEvents
```
uncollectEvents :: [Event [a]] -> [Event a] 
```

### uncollect
```
uncollect :: Pattern [a] -> Pattern a 
```

merges all values in a list into one pattern by stacking the values

### module 
```
module Sound.Tidal.Time
```

