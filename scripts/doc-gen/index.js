import { basename, resolve } from "path";
import { createWriteStream } from "fs";
import { readdir, readFile, rm, mkdir, writeFile } from "fs/promises";
import { parse } from "parse5";

import { Tree } from "./tree.js";

if (!process.argv[2]) {
  console.log("Please provide a path to documentation folder");
} else {
  generateDocs(process.argv[2]);
}

async function generateDocs(path) {
  let modules = (await readdir(path)).filter(p => p.startsWith("Sound-Tidal-"));

  // Clear out autogenerated folder (rm -rf)
  await rm("../../docs/library/autogenerated", { recursive: true, force: true });

  let modulePromises = [];

  for (let module of modules) {
    modulePromises.push(generateModuleDocs(resolve(path, module)));
  }

  let modulePaths = await Promise.all(modulePromises);
  await writeFile("../../docs/library/autogenerated/sidebar.json", JSON.stringify(modulePaths));
}

async function generateModuleDocs(path) {
  let moduleSlug = basename(path, ".html");
  let moduleName = moduleSlug.replaceAll("-", ".");
  let moduleFile = moduleSlug + ".mdx";

  let sidebarPrefix = "library/autogenerated";
  let folderPath = resolve("../../docs", sidebarPrefix, moduleSlug);
  await mkdir(folderPath, { recursive: true });

  let sidebarPath = `${sidebarPrefix}/${moduleSlug}/${moduleSlug}`;

  let modulePath = resolve(folderPath, moduleFile);
  let outputStream = createWriteStream(modulePath);

  function write(text) {
    outputStream.write(text);
  }

  function writeLn(text, num = 1) {
    outputStream.write(text + "\n".repeat(num));
  }

  function header(module, frontmatter) {
    writeLn("---");
    for (let key in frontmatter) {
      writeLn(`${key}: ${frontmatter[key]}`);
    }
    writeLn("---", 2);

    let srcPath = module.split(".").join("/");
    writeLn(
`<!------------------------------------------------------------------------------
THIS IS A DOC FILE AUTOMATICALLY GENERATED FROM:

https://github.com/tidalcycles/Tidal/blob/main/src/${srcPath}.hs

It's based on the documentation comments in the Tidal code.
Do not edit it directly--to update this documentation, please submit a
change to the original file in the Tidal repository. Thanks!
------------------------------------------------------------------------------->`, 2);
  }

  header(moduleName, { title: moduleName, slug: `/library/modules/${moduleName}`});

  let tree = new Tree(parse(await readFile(path, "utf-8")));

  let nodes = tree.getChild("html")
                  .getChild("body")
                  .getChildID("content")
                  .getChildID("interface").childNodes;

  for (let node of nodes) {
    if (node.hasClass("top")) {
      let [src, desc] = node.childNodes;
      
      // Write out definition
      let [def, ...typeParts] = src.childNodes;
      let funcName = def.text;
      let type = typeParts.filter(n => !(n.hasClass("link") || n.hasClass("selflink"))).map(n => n.text).join("");
      let typeSig = `${funcName}${type}`
      writeLn(`### ${funcName}`);
      writeLn("```");
      writeLn(`${typeSig}`);
      writeLn("```", 2);

      if (desc && desc.hasClass("doc")) {
        for (let paragraph of desc.childNodes) {
          if (paragraph.tagName === "p") {
            for (let part of paragraph.childNodes) {
              if (part.tagName === "code") {
                write(`\`${part.text}\``);
              } else {
                write(part.text);
              }
            }
            writeLn("", 2);
          } else if (paragraph.tagName === "pre") {
            writeLn("```haskell");
            write(paragraph.text);
            writeLn("```");
          }
        }
      }
    } else if (node.tagName === "a" && node.getChild("h2")) {
      writeLn(`## ${node.text}`);
    }
  }

  outputStream.close();

  return sidebarPath;
}