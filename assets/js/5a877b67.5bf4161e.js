(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{113:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return c}));var a=n(3),r=n(7),o=(n(0),n(214)),i={title:"Composition",id:"composition"},s={unversionedId:"patternlib/tour/composition",id:"patternlib/tour/composition",isDocsHomePage:!1,title:"Composition",description:"This page will present you all the functions that can be used to compose long form pieces with Tidal Cycles. Each function will be presented following the same model:",source:"@site/docs/patternlib/tour/composition.md",slug:"/patternlib/tour/composition",permalink:"/docs/patternlib/tour/composition",editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/patternlib/tour/composition.md",version:"current",lastUpdatedBy:"Raphael Forment",lastUpdatedAt:1621810431,sidebar:"docs",previous:{title:"Randomness",permalink:"/docs/patternlib/tour/randomness"},next:{title:"Haskell",permalink:"/docs/innards/haskell"}},l=[{value:"ur",id:"ur",children:[]},{value:"seqP",id:"seqp",children:[]},{value:"seqPLoop",id:"seqploop",children:[]}],p={toc:l};function c(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This page will present you all the functions that can be used to compose long form pieces with ",Object(o.b)("strong",{parentName:"p"},"Tidal Cycles"),". Each function will be presented following the same model:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Type signature"),": how the function is declared on the ",Object(o.b)("strong",{parentName:"li"},"Haskell")," side."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Description"),": verbal description of the function."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Examples"),": a small list of examples that you can copy/paste in your editor.")),Object(o.b)("h2",{id:"ur"},"ur"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Type: ur :: Time -> Pattern String -> [(String, Pattern a)] -> [(String, Pattern a -> Pattern a)] -> Pattern a\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"ur")," function is designed for longer form composition, by allowing you to create 'patterns of patterns' in a repeating loop. It takes three parameters -- how long the loop will take, a pattern giving the structure of the composition, a lookup table for named patterns to feed into that structure, and a second lookup table for named transformations/fx."),Object(o.b)("p",null,"Lets say you had three patterns (called ",Object(o.b)("inlineCode",{parentName:"p"},"a"),", ",Object(o.b)("inlineCode",{parentName:"p"},"b")," and ",Object(o.b)("inlineCode",{parentName:"p"},"c"),"), and that you wanted to play them four cycles each, over twelve cycles in total. Here is one way to do it:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'let pats =\n      [\n        ("a", stack [n "c4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",\n                     n "[c3,g4,c4]" # s "superpiano"# gain "0.7"\n                    ]\n        ),\n        ("b", stack [n "d4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",\n                     n "[d3,a4,d4]" # s "superpiano"# gain "0.7"\n                    ]\n        ),\n        ("c", stack [n "f4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",\n                     n "[f4,c5,f4]" # s "superpiano"# gain "0.7"\n                    ]\n        )\n      ]\nin\nd1 $ ur 12 "a b c" pats []\n')),Object(o.b)("p",null,"In ",Object(o.b)("inlineCode",{parentName:"p"},'ur 12 "a b c" pats []'),", the ",Object(o.b)("inlineCode",{parentName:"p"},"12")," is the duration of the loop (in cycles), the ",Object(o.b)("inlineCode",{parentName:"p"},'"a b c"')," is the structure of named patterns, and pats is the lookup table, defined above. So the ",Object(o.b)("inlineCode",{parentName:"p"},'"a b c"')," pattern happens over the 12 cycles, with the ",Object(o.b)("inlineCode",{parentName:"p"},"a"),", ",Object(o.b)("inlineCode",{parentName:"p"},"b")," and ",Object(o.b)("inlineCode",{parentName:"p"},"c")," standing in for each of the three patterns given in the lookup table. Because there are three events in this pattern, and it happens over 12 cycles. then each event is four cycles long."),Object(o.b)("p",null,"In the above, the fourth parameter is given as an empty list, but that is where you can put another lookup table, of functions rather than patterns this time. Here's an example:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'let pats =\n      [\n        ("a", stack [n "c4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",\n                     n "[c3,g4,c4]" # s "superpiano"# gain "0.7"\n                    ]\n        ),\n        ("b", stack [n "d4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",\n                     n "[d3,a4,d4]" # s "superpiano"# gain "0.7"\n                    ]\n        ),\n        ("c", stack [n "f4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",\n                     n "[f4,c5,f4]" # s "superpiano"# gain "0.7"\n                    ]\n        )\n      ]\n    fx = [("reverb", (# (room 0.8 # sz 0.99 # orbit 1))),\n          ("faster", fast 2)\n         ]\nin\nd1 $ ur 12 "a b:reverb c:faster" pats fx\n')),Object(o.b)("p",null,"In the above, ",Object(o.b)("inlineCode",{parentName:"p"},"b")," has the function applied that's named as reverb, while ",Object(o.b)("inlineCode",{parentName:"p"},"c")," is made to go faster. It's also possible to schedule multiple patterns at once, like in the following:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'let pats = [("drums", s "drum cp*2"),\n            ("melody", s "arpy:2 arpy:3 arpy:5"),\n            ("craziness", s "cp:4*8" # speed ( sine + 0.5))\n           ]\n    fx = [("higher", (# speed 2))]\nin\nd1 $ ur 8 "[drums, melody] [drums,craziness,melody] melody:higher" pats fx\n')),Object(o.b)("h2",{id:"seqp"},"seqP"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Type: seqP :: [(Time, Time, Pattern a)] -> Pattern a\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"seqP")," allows you sequence patterns, with start and end times. The code below contains three separate patterns in a ",Object(o.b)("inlineCode",{parentName:"p"},"stack"),", but each has different start times (zero cycles, four cycles, and eight cycles, respectively). In the example, all patterns stop after 12 cycles:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ seqP [ \n  (0, 12, sound "bd bd*2"), \n  (4, 12, sound "hh*2 [sn cp] cp future*4"), \n  (8, 12, sound (samples "arpy*8" (run 16)))\n]\n')),Object(o.b)("p",null,"If you run the above, you probably won\u2019t hear anything. This is because cycles start ticking up as soon as you start ",Object(o.b)("strong",{parentName:"p"},"Tidal"),", and you have probably already gone past cycle 12."),Object(o.b)("p",null,"You can reset the cycle clock back to zero by running ",Object(o.b)("inlineCode",{parentName:"p"},"setcps (-1)")," followed by ",Object(o.b)("inlineCode",{parentName:"p"},"setcps 1")," (nb: at the time of writing, this doesn't yet work in version ",Object(o.b)("inlineCode",{parentName:"p"},"1.0.0")," of tidal, but you can instead run ",Object(o.b)("inlineCode",{parentName:"p"},"resetCycles"),"), or whatever tempo you want to restart at. Alternatively, you can shift time for the seqP pattern back to zero like this:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ qtrigger 1 $ seqP [ \n  (0, 12, sound "bd bd*2"), \n  (4, 12, sound "hh*2 [sn cp] cp future*4"), \n  (8, 12, sound (samples "arpy*8" (run 16)))\n]\n')),Object(o.b)("h2",{id:"seqploop"},"seqPLoop"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Type: seqPLoop :: [(Time, Time, Pattern a)] -> Pattern a\n")),Object(o.b)("p",null,"A third option is to use ",Object(o.b)("inlineCode",{parentName:"p"},"seqPLoop")," instead, which will keep looping the sequence when it gets to the end:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ qtrigger 1 $ seqPLoop [ \n  (0, 12, sound "bd bd*2"), \n  (4, 12, sound "hh*2 [sn cp] cp future*4"), \n  (8, 12, sound (samples "arpy*8" (run 16)))\n]\n')),Object(o.b)("p",null,"For building and testing out longer sequences, it may be helpful to skip cycles with ",Object(o.b)("inlineCode",{parentName:"p"},"rotL"),". "))}c.isMDXComponent=!0},214:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),c=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,m=u["".concat(i,".").concat(d)]||u[d]||b[d]||o;return n?r.a.createElement(m,s(s({ref:t},p),{},{components:n})):r.a.createElement(m,s({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);