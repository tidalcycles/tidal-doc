"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9002],{3905:(e,a,n)=>{n.d(a,{Zo:()=>d,kt:()=>h});var t=n(7294);function l(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function s(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){l(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function o(e,a){if(null==e)return{};var n,t,l=function(e,a){if(null==e)return{};var n,t,l={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(l[n]=e[n]);return l}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var p=t.createContext({}),i=function(e){var a=t.useContext(p),n=a;return e&&(n="function"==typeof e?e(a):s(s({},a),e)),n},d=function(e){var a=i(e.components);return t.createElement(p.Provider,{value:a},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},m=t.forwardRef((function(e,a){var n=e.components,l=e.mdxType,r=e.originalType,p=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=i(n),m=l,h=u["".concat(p,".").concat(m)]||u[m]||c[m]||r;return n?t.createElement(h,s(s({ref:a},d),{},{components:n})):t.createElement(h,s({ref:a},d))}));function h(e,a){var n=arguments,l=a&&a.mdxType;if("string"==typeof e||l){var r=n.length,s=new Array(r);s[0]=m;var o={};for(var p in a)hasOwnProperty.call(a,p)&&(o[p]=a[p]);o.originalType=e,o[u]="string"==typeof e?e:l,s[1]=o;for(var i=2;i<r;i++)s[i]=n[i];return t.createElement.apply(null,s)}return t.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9075:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>i});var t=n(3117),l=(n(7294),n(3905));const r={title:"Workshop",id:"workshop"},s=void 0,o={unversionedId:"patternlib/tutorials/workshop",id:"patternlib/tutorials/workshop",title:"Workshop",description:"----",source:"@site/docs/patternlib/tutorials/workshop.md",sourceDirName:"patternlib/tutorials",slug:"/patternlib/tutorials/workshop",permalink:"/docs/patternlib/tutorials/workshop",draft:!1,editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/patternlib/tutorials/workshop.md",tags:[],version:"current",lastUpdatedAt:1688664001,formattedLastUpdatedAt:"Jul 6, 2023",frontMatter:{title:"Workshop",id:"workshop"},sidebar:"docs",previous:{title:"Typing fast and well",permalink:"/docs/around_tidal/typing_fast_and_well"},next:{title:"Course I (> 1.6)",permalink:"/docs/patternlib/tutorials/course1"}},p={},i=[{value:"Getting started",id:"getting-started",level:2},{value:"Estuary",id:"estuary",level:3},{value:"Notes in Haskell",id:"notes-in-haskell",level:3},{value:"Basic patterns",id:"basic-patterns",level:2},{value:"Default sample library",id:"default-sample-library",level:3},{value:"More variety",id:"more-variety",level:3},{value:"Effects",id:"effects",level:2},{value:"Vowel",id:"vowel",level:3},{value:"Gain, pitch and panorama",id:"gain-pitch-and-panorama",level:3},{value:"Distortion, reverb, delay and filters",id:"distortion-reverb-delay-and-filters",level:3},{value:"Transforming patterns",id:"transforming-patterns",level:2},{value:"Slow, fast and hurry",id:"slow-fast-and-hurry",level:3},{value:"Reorganise patterns",id:"reorganise-patterns",level:3},{value:"Even further into transformations",id:"even-further-into-transformations",level:3},{value:"Different kind of patterns",id:"different-kind-of-patterns",level:2},{value:"Cyclic / repetitive",id:"cyclic--repetitive",level:3},{value:"Symmetry",id:"symmetry",level:3},{value:"Polymetric / polyrhythmic sequences",id:"polymetric--polyrhythmic-sequences",level:3},{value:"Euclidean rhythm/Bjorklund",id:"euclidean-rhythmbjorklund",level:3},{value:"Randomness",id:"randomness",level:2},{value:"Manipulating Samples",id:"manipulating-samples",level:2},{value:"Superdirt synthesizers",id:"superdirt-synthesizers",level:2},{value:"Difference between functions <code>n</code> and <code>note</code>",id:"difference-between-functions-n-and-note",level:3},{value:"Playing notes",id:"playing-notes",level:2},{value:"Where to go from here",id:"where-to-go-from-here",level:2}],d={toc:i};function u(e){let{components:a,...n}=e;return(0,l.kt)("wrapper",(0,t.Z)({},d,n,{components:a,mdxType:"MDXLayout"}),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Welcome to this ",(0,l.kt)("strong",{parentName:"p"},"Tidal Cycles")," tutorial. This is designed to be used as a worksheet during hands-on beginner/mixed workshops. By Lucy Cheesman, adapted to wiki format by Alex McLean."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"getting-started"},"Getting started"),(0,l.kt)("p",null,"Once everything is installed, follow the following startup procedure\neach time."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Launch ",(0,l.kt)("strong",{parentName:"p"},"SuperDirt")),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"SuperDirt")," should be started automatically when you run the ",(0,l.kt)("strong",{parentName:"p"},"SuperCollider IDE")," application. If not, in the editor window of the ",(0,l.kt)("strong",{parentName:"p"},"SuperCollider IDE"),", type ",(0,l.kt)("inlineCode",{parentName:"p"},"'SuperDirt.start'")," and run the code by holding down ",(0,l.kt)("inlineCode",{parentName:"p"},"Ctrl")," and pressing ",(0,l.kt)("inlineCode",{parentName:"p"},"Enter")," (while your cursor is on the same line as the code).")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Launch ",(0,l.kt)("strong",{parentName:"p"},"Tidal Cycles")),(0,l.kt)("p",{parentName:"li"},"In your text editor (Pulsar, vim, VS Code, etc), start a new file and save it with a ",(0,l.kt)("inlineCode",{parentName:"p"},".tidal")," extension (e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},"examples.tidal"),"). ",(0,l.kt)("strong",{parentName:"p"},"Tidal")," will be automatically launch when you type and execute your first command."))),(0,l.kt)("h3",{id:"estuary"},"Estuary"),(0,l.kt)("p",null,"Even if you haven't installed ",(0,l.kt)("strong",{parentName:"p"},"Tidal")," on your computer yet, it's still possible to play with it online. ",(0,l.kt)("a",{parentName:"p",href:"https://estuary.mcmaster.ca/"},"Estuary")," lets you play with ",(0,l.kt)("strong",{parentName:"p"},"Tidal")," and several other live-coding systems inside your browser, without the need to install anything in your own computer."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Estuary")," is a perfect place to learn, teach, play with others, and test distinct live-coding languages."),(0,l.kt)("p",null,"However, note that not all features in ",(0,l.kt)("strong",{parentName:"p"},"Tidal")," will work on ",(0,l.kt)("strong",{parentName:"p"},"Estuary"),", only a subset (called ",(0,l.kt)("strong",{parentName:"p"},"Mini-Tidal"),")."),(0,l.kt)("h3",{id:"notes-in-haskell"},"Notes in Haskell"),(0,l.kt)("p",null,"Haskell uses double dashes ",(0,l.kt)("inlineCode",{parentName:"p"},"--")," at the beginning of a line to denote a comment. A comment is code that will be ignored by the interpreter. You can use comments to add notes in your code. You can also use comments to ignore a specific line or pattern:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'\u2013- I\'m a comment\n\n-- this pattern will not play\n-- d1 $\xa0s "bd hh sn hh"\n\n-- "fast 2" will be ignored\nd1\n--  $\xa0fast 2\n  $ s "hh*8"\n\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"basic-patterns"},"Basic patterns"),(0,l.kt)("p",null,"The basic format for making sound in Tidal looks like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "drum"\n')),(0,l.kt)("p",null,"You can stop making a sound using ",(0,l.kt)("inlineCode",{parentName:"p"},"silence"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"d1 $ silence\n")),(0,l.kt)("p",null,"There are two types of sounds you can use with ",(0,l.kt)("inlineCode",{parentName:"p"},"sound"),": either they are synths definitions (like ",(0,l.kt)("inlineCode",{parentName:"p"},"superpiano"),", see ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/synthesizers"},"Synthesizers"),"), or they are samples. In the latter case, you write the name of the folder that contain the sample set. By default, the first sample is used, but you can pick a different sample from the same set, with ",(0,l.kt)("inlineCode",{parentName:"p"},":"),": and a number:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "drum:1"\n')),(0,l.kt)("p",null,"Also, it is possible to specify the folder and the sample in two parts:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "drum" # n 1\n')),(0,l.kt)("p",null,"Note that ",(0,l.kt)("inlineCode",{parentName:"p"},"s")," is a synonym of ",(0,l.kt)("inlineCode",{parentName:"p"},"sound"),", so ",(0,l.kt)("inlineCode",{parentName:"p"},'d1 $ s "drum" # n 1')," is the same pattern."),(0,l.kt)("h3",{id:"default-sample-library"},"Default sample library"),(0,l.kt)("p",null,"Some of the samples which come with ",(0,l.kt)("strong",{parentName:"p"},"Tidal")," are listed below. Try some out!"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plaintext"},"flick sid can metal future gabba sn mouth co gretsch mt arp h cp\ncr newnotes bass hc tabla bass0 hh bass1 bass2 oc bass3 ho odx\ndiphone2 house off ht tink perc bd industrial pluck trump printshort\njazz voodoo birds3 procshort blip drum jvbass psr wobble drumtraks koy\nrave bottle kurt latibro rm sax lighter lt arpy feel less stab ul\n")),(0,l.kt)("p",null,"You can see what other sounds there are in the ",(0,l.kt)("a",{parentName:"p",href:"/docs/configuration/AudioSamples/default_library"},"default library")," by looking in the ",(0,l.kt)("inlineCode",{parentName:"p"},"Dirt-Samples")," folder. Find it via the ",(0,l.kt)("inlineCode",{parentName:"p"},"SuperCollider")," menu: ",(0,l.kt)("inlineCode",{parentName:"p"},"'File > Open user support directory > downloaded-quarks > Dirt-Samples'"),". Additionally, you can also add your own ",(0,l.kt)("a",{parentName:"p",href:"/docs/configuration/AudioSamples/audiosamples"},"custom samples"),". In the Pulsar editor, you can add a setting that will load a tab with all the Dirt-Samples (see ",(0,l.kt)("a",{parentName:"p",href:"/docs/getting-started/editor/Pulsar"},"Pulsar"),"). "),(0,l.kt)("p",null,"Make a sequence:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd hh sn hh"\n')),(0,l.kt)("p",null,"The more steps in the sequence, the faster it goes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd bd hh bd sn bd hh bd"\n')),(0,l.kt)("p",null,"This is because of the way ",(0,l.kt)("strong",{parentName:"p"},"Tidal")," handles time. There is a universal ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/cycles"},"cycle")," (sort of like a musical 'bar') which is always running. ",(0,l.kt)("strong",{parentName:"p"},"Tidal")," will play all of the sounds between the speech marks in one cycle, unless we tell it not to (we\u2019ll learn how to do that later). You\u2019ll also notice ",(0,l.kt)("inlineCode",{parentName:"p"},"Tidal")," will space the sounds out evenly within the cycle Which means we can end up with polyrhythmic structures (more on those later). We can change the length of the cycle using ",(0,l.kt)("inlineCode",{parentName:"p"},"setcps")," (where ",(0,l.kt)("inlineCode",{parentName:"p"},"cps")," stands for cycles per second) - this is a bit like bpm (beats per minute)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"setcps 0.6\n")),(0,l.kt)("p",null,"You can use ",(0,l.kt)("inlineCode",{parentName:"p"},"d1, d2, d3...d9")," to play multiple sequences at the same time:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d2 $ sound "sn sn:2 sn bd sn"\n')),(0,l.kt)("p",null,"You can stop all the running patterns with ",(0,l.kt)("inlineCode",{parentName:"p"},"hush")," (or by pressing ",(0,l.kt)("inlineCode",{parentName:"p"},"Ctrl+."),")."),(0,l.kt)("p",null,"You can pause everything by changing the cycle length to a negative number (remember to put negative numbers in brackets)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"setcps (-1)\n")),(0,l.kt)("p",null,"Start it up again with a positive number"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"setcps 0.6\n")),(0,l.kt)("p",null,"Or you can ",(0,l.kt)("inlineCode",{parentName:"p"},"solo")," one channel:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "arpy cp arpy:2"\nd2 $ sound "sn sn:2 bd sn"\n\nsolo 2\n\n-- now only the second pattern will be playing\n\nunsolo 2\n\n-- now both will be playing, again\n\nmute 2\n\n-- now only the first pattern will be playing\n\nunmute 2 -- (or unmuteAll)\n\n-- now both will be playing\n')),(0,l.kt)("p",null,"The Pulsar plugin adds some key shortcuts for this common operations, like ",(0,l.kt)("inlineCode",{parentName:"p"},"Ctrl+1")," to toggle mute for the first pattern, or ",(0,l.kt)("inlineCode",{parentName:"p"},"Ctrl+0")," to unmute all. You can see the complete list of keybindings inside Pulsar, by going to ",(0,l.kt)("inlineCode",{parentName:"p"},"Edit > Preferences > Packages"),", selecting tidalcycles, and scrolling down to the ",(0,l.kt)("inlineCode",{parentName:"p"},"Keybindings")," section."),(0,l.kt)("h3",{id:"more-variety"},"More variety"),(0,l.kt)("p",null,"Let's add some more variety to our sequences:"),(0,l.kt)("p",null,"Add a silence/rest with ",(0,l.kt)("inlineCode",{parentName:"p"},"~"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd ~ sn:3 bd sn:5 ~ bd:2 sn:2"\n')),(0,l.kt)("p",null,"Fit a subsequence into a step with square brackets:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd [bd cp] bd bd"\n')),(0,l.kt)("p",null,"This can make for flexible time signatures:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "[bd bd sn:5] [bd sn:3]"\n')),(0,l.kt)("p",null,"You can put subsequences inside subsequences:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "[[bd bd] bd sn:5] [bd sn:3]"\n')),(0,l.kt)("p",null,"Keep going.."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "[[bd [bd bd bd bd]] bd sn:5] [bd sn:3]"\n')),(0,l.kt)("p",null,"You can repeat a step with ",(0,l.kt)("inlineCode",{parentName:"p"},"*"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd sd*2"\n')),(0,l.kt)("p",null,"This works with subsequences too:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd [sd cp]*2"\n')),(0,l.kt)("p",null,"Or you can do the opposite using ",(0,l.kt)("em",{parentName:"p"},"/"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd sn/2"\nd1 $ sound "bd [sn cp]/2"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"*")," works by 'speeding up' a step to play it multiple times. ",(0,l.kt)("inlineCode",{parentName:"p"},"/")," works by 'slowing it down'."),(0,l.kt)("p",null,"We can also schedule patterns across cycles using ",(0,l.kt)("inlineCode",{parentName:"p"},"<")," and ",(0,l.kt)("inlineCode",{parentName:"p"},">"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd <sd cp arpy>"\nd1 $ sound "<bd sn> <sd [cp cp]> <bd [cp cp]>"\n')),(0,l.kt)("p",null,"The syntax we are using in these examples is called ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/mini_notation"},"mini-notation"),", and can be used in many places within Tidal, not only the ",(0,l.kt)("inlineCode",{parentName:"p"},"sound")," function."),(0,l.kt)("p",null,"Other common mini-notation symbols are ",(0,l.kt)("inlineCode",{parentName:"p"},"|")," to choose a random option, ",(0,l.kt)("inlineCode",{parentName:"p"},",")," to play two patterns simultaneously, and ",(0,l.kt)("inlineCode",{parentName:"p"},"!")," to replicate a pattern."),(0,l.kt)("p",null,"Choose one of the two samples randomly:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "[bd:0|bd:1]"\nd1 $ sound "[sn|cp]"\n')),(0,l.kt)("p",null,"Play a snare and a clap at the same time:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "[sn,cp]"\n')),(0,l.kt)("p",null,"Play three bass drums and a snare:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd!3 sn"\n')),(0,l.kt)("p",null,"Note the difference between this and ",(0,l.kt)("inlineCode",{parentName:"p"},'"bd*3 sn"'),": in the first example there are four events, all of them lasting the same time. In the latter, the three ",(0,l.kt)("inlineCode",{parentName:"p"},"bd")," last for half a cycle, and the ",(0,l.kt)("inlineCode",{parentName:"p"},"sn")," lasts the other half. ",(0,l.kt)("inlineCode",{parentName:"p"},'"bd!3 sn"')," is the same as ",(0,l.kt)("inlineCode",{parentName:"p"},"bd bd bd sn"),"."),(0,l.kt)("h2",{id:"effects"},"Effects"),(0,l.kt)("h3",{id:"vowel"},"Vowel"),(0,l.kt)("p",null,"Tidal has lots of effects we can use to change the way things sound. ",(0,l.kt)("inlineCode",{parentName:"p"},"vowel")," is a filter which adds a vowel sound -- try ",(0,l.kt)("inlineCode",{parentName:"p"},"a, e, i, o")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"u"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "drum drum drum drum" # vowel "a"\n')),(0,l.kt)("p",null,"We create patterns of effects in much the same way we create patterns of sounds. We call these effect and sound patterns 'control patterns'. So:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "drum drum drum drum" # vowel "a o e e"\n')),(0,l.kt)("p",null,"Remember that we can use ",(0,l.kt)("inlineCode",{parentName:"p"},'"<>"')," to schedule across cycles:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "drum drum drum drum" # vowel "<a o e e>"\n')),(0,l.kt)("p",null,"You can add a non-vowel letter to pause the ",(0,l.kt)("inlineCode",{parentName:"p"},"vowel")," effect:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "drum drum drum drum" # vowel "a o p p"\n')),(0,l.kt)("p",null,"Tidal does its best to map patterns across to one another:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "drum drum drum drum" # vowel "a o e"\n')),(0,l.kt)("p",null,"The structure comes from the left - try swapping the parameters:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ vowel "a o ~ i" # sound "drum"\n')),(0,l.kt)("h3",{id:"gain-pitch-and-panorama"},"Gain, pitch and panorama"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"gain")," changes the volume of different sounds:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd hh sn:1 hh sn:1 hh" # gain "1 0.7 0.5"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"speed")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"note")," are used for pitching samples. ",(0,l.kt)("inlineCode",{parentName:"p"},"speed")," affects the speed of playback (e.g. 2 = up an octave):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "numbers:1 numbers:2 numbers:3 numbers:4" # speed "1 1.5 2 0.5"\n')),(0,l.kt)("p",null,"Or we can take the pattern from the speed parameter:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ speed "1 2 4" # sound "jungbass:6"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"note")," pitches the sample up in semitones (e.g. 12 = up an octave):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ up "0 ~ 12 24" # sound "jungbass:6"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"pan")," allows us to create stereo effects (0 = left, 0.5 = middle, 1 = right):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "numbers:1 numbers:2 numbers:3 numbers:4" # pan "0 0.5 1"\n')),(0,l.kt)("h3",{id:"distortion-reverb-delay-and-filters"},"Distortion, reverb, delay and filters"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"shape")," is one of the several function you can use to add ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/audio_effects/#distortion"},"distortion")," (but be careful - it also makes the sound much louder):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "kurt:4 kurt:4" # shape "0 0.78" # gain "0.7"\n')),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"/docs/reference/audio_effects#delay"},"Delay")," is achieved using the combination of up to four functions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "cp" # delay 0.8 # delaytime (1/6) # delayfeedback 0.6 # lock 1\n')),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"lock 1")," to indicate that the time provided to ",(0,l.kt)("inlineCode",{parentName:"p"},"delaytime")," is in cycles instead of seconds."),(0,l.kt)("p",null,"All of them receive patterns:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "industrial:3*4" # delay "<0 0.4 0.8>" # delaytime "0.2 0.05" # delayfeedback "<0.5 0.9>" # lock 1\n')),(0,l.kt)("p",null,"To add a ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/audio_effects#reverb"},"reverb")," effect use the functions ",(0,l.kt)("inlineCode",{parentName:"p"},"dry"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"room")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"size"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "[~ sn]*2" # dry 0.4 # room 0.6 # size 0.8\n')),(0,l.kt)("p",null,"There are also several frequency ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/audio_effects/#filters"},"filters")," available: low pass, high pass, dj type filter, among others."),(0,l.kt)("p",null,"Low pass filter:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "tabla*4" # n "0 1 2 3" # cutoff 400 # resonance 0.2\n')),(0,l.kt)("p",null,"High pass filter:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "tabla*4" # n "0 1 2 3" # hcutoff 600 # hresonance 0.2\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"cutoff")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"hcutoff")," receive the frequency in hertz of the cutoff point. ",(0,l.kt)("inlineCode",{parentName:"p"},"resonance")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"hresonance")," go from 0 to 1, but be aware that high resonance values can result in a very loud sound."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"djf")," is a more immediate filter: it receives a number between 0 and 1. With values lesser than 0.5 it is a low pass filter, and with values greater than 0.5 it is a high pass filter."),(0,l.kt)("p",null,"You can take a look at the ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/audio_effects"},"Effects")," section to learn more about effects and to see the complete list of effects."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"transforming-patterns"},"Transforming patterns"),(0,l.kt)("p",null,"We can start to make much more complex patterns using transformations. Using functions like ",(0,l.kt)("inlineCode",{parentName:"p"},"slow")," you can start to transcend the cycle. ",(0,l.kt)("inlineCode",{parentName:"p"},"slow")," stretches the pattern over more cycles:"),(0,l.kt)("h3",{id:"slow-fast-and-hurry"},"Slow, fast and hurry"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "arpy arpy:1 arpy:2 arpy:3"\n\nd1 $ slow 2 $ sound "arpy arpy:1 arpy:2 arpy:3"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"fast")," squashes the pattern into less than one cycle. You might also see people writing ",(0,l.kt)("inlineCode",{parentName:"p"},"density")," - it\u2019s the same thing. Take a look:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'fast 0.5 is the same as slow 2!\n\nd1 $ fast 2 $ sound "arpy arpy:1 arpy:2 arpy:3"\nd1 $ fast 0.5 $ sound "arpy arpy:1 arpy:2 arpy:3"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"hurry")," is similar to ",(0,l.kt)("inlineCode",{parentName:"p"},"fast"),", but also applies a speed transformation:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "arpy arpy arpy:1 arpy:2"\nd1 $ hurry 2 $ sound "arpy arpy arpy:1 arpy:2"\nd1 $ hurry 0.5 $ sound "arpy arpy arpy:1 arpy:2"\n')),(0,l.kt)("p",null,"See the ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/time"},"Time")," section in the Reference to learn more about time-changing functions."),(0,l.kt)("h3",{id:"reorganise-patterns"},"Reorganise patterns"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Tidal Cycles")," offers many functions you can use to alter your patterns in different ways. In this section, some of them are introduced, but there are many more. You can check these reference sections to find more: ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/alteration"},"alteration"),", ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/accumulation"},"accumulation")," and ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/conditions"},"conditions"),"."),(0,l.kt)("p",null,"You can reverse a pattern with ",(0,l.kt)("inlineCode",{parentName:"p"},"rev"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ rev $ sound "arpy arpy:1 arpy:2 arpy:3"\n')),(0,l.kt)("p",null,"Or play it forwards and then backwards with ",(0,l.kt)("inlineCode",{parentName:"p"},"palindrome"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ palindrome $ sound "arpy arpy:1 arpy:2 arpy:3"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"iter")," starts the pattern at a different point each cycle, shifting it the given number of times until it gets back to where it started:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ iter 4 $ sound "arpy arpy:1 arpy:2 arpy:3"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"every")," allows us to schedule transformations or effects in different cycles. The following example will play twice as fast every four cycles:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ every 4 (fast 2) $ sound "arpy arpy:1 arpy:2 arpy:3"\n')),(0,l.kt)("p",null,"... or you could schedule an effect in the same way, using ",(0,l.kt)("inlineCode",{parentName:"p"},"#"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ every 4 (# vowel "a o") $ sound "arpy arpy:1 arpy:2 arpy:3"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"jux")," (short for ",(0,l.kt)("inlineCode",{parentName:"p"},"juxtapose"),") takes a transformation or an effect and plays it in one speaker the original pattern plays in the other speaker:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "arpy arpy:1 arpy:2 arpy:3"\nd1 $ jux (rev) $ sound "arpy arpy:1 arpy:2 arpy:3"\nd1 $ jux (hurry 2) $ sound "arpy arpy arpy:1 arpy:2"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"chunk")," applies a transformation or an effect to a different part of the pattern each time. For example with 4 as a parameter, it will step through each quarter of the cycle."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ chunk 4 (hurry 2) $ sound  "arpy arpy:1 arpy:2 arpy:3"\nd1 $ chunk 4 (# speed 2) $ sound  "alphabet:0 alphabet:1 alphabet:2 alphabet:3"\n')),(0,l.kt)("h3",{id:"even-further-into-transformations"},"Even further into transformations"),(0,l.kt)("p",null,"More than one transformation is possible! You can chain them together using ",(0,l.kt)("inlineCode",{parentName:"p"},"."),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ jux (rev . (slow 1.5)) $ sound "arpy arpy:1 arpy:2 arpy:3"\n')),(0,l.kt)("p",null,"Remember that (almost) everything is a pattern so we can apply these transformations to our effects too:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "jvbass [jvbass jvbass] jvbass ~" # note "1 [3 5] 7"\nd1 $ sound "jvbass [jvbass jvbass] jvbass ~" # iter 3 (note "1 [3 5] 7")\n')),(0,l.kt)("p",null,"You can create an LFO on any parameter by using ",(0,l.kt)("inlineCode",{parentName:"p"},"fast")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"slow"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"range"),",  and an oscillator such as ",(0,l.kt)("inlineCode",{parentName:"p"},"sine")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"saw"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ d1 $ s "bd*8" # pan (slow 4 $ sine)\nd1 $ s "moog*16" # n "<0 1 2>" # legato 1 # cutoff (range 200 2400 $ saw) # resonance 0.2\n')),(0,l.kt)("p",null,"By default, ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/oscillators"},"oscillators")," such as ",(0,l.kt)("inlineCode",{parentName:"p"},"sine"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"cosine")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"saw")," give values from 0 to 1. This is fine for some parameters (like ",(0,l.kt)("inlineCode",{parentName:"p"},"pan"),"), but you can use ",(0,l.kt)("inlineCode",{parentName:"p"},"range")," to scale these values to whatever range you want."),(0,l.kt)("p",null,"The previous examples trigger one oscillator value for event. This is fine if there are a lot of events per cycle. However, if there are fewer, longer events, we need to pick several values from the oscillator in order to accomplish a smooth movement of the LFO. You can do this using ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/control_busses"},"control busses"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ s "moog" # n "<0 1 2>" # legato 1 # cutoffbus 1 (segment 32 $ range 200 2400 $ saw) # resonance 0.2\n')),(0,l.kt)("p",null,"Here we can hear how the sound changes gradually during the cycle. There are busses for many parameters, all of them named like the parameter plus ",(0,l.kt)("inlineCode",{parentName:"p"},"bus"),". In this last example, ",(0,l.kt)("inlineCode",{parentName:"p"},"segment 32")," tells the oscillator to pick 32 values each cycle."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"different-kind-of-patterns"},"Different kind of patterns"),(0,l.kt)("p",null,"What is pattern, anyway? Let's think about some different kinds of pattern and how ",(0,l.kt)("strong",{parentName:"p"},"Tidal")," can represent them."),(0,l.kt)("h3",{id:"cyclic--repetitive"},"Cyclic / repetitive"),(0,l.kt)("p",null,"We can use ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," to choose samples from a folder, this allows us to apply patterns there too:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ n "0 1 2 3" # sound "arpy"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"run")," is a short way of writing out sequential patterns:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ n (run 4) # sound "arpy"\n')),(0,l.kt)("p",null,"or we can use:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ n "0 .. 3" # sound "arpy"\n')),(0,l.kt)("h3",{id:"symmetry"},"Symmetry"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 2 $ n "0 1 2 3 3 2 1 0" # sound "arpy"\nd1 $ palindrome $ n (run 4) # sound "arpy"\n')),(0,l.kt)("h3",{id:"polymetric--polyrhythmic-sequences"},"Polymetric / polyrhythmic sequences"),(0,l.kt)("p",null,"Play two subsequences at once by using square brackets (sort of like one big subsequence!) separating with a comma:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "[voodoo voodoo:3, arpy arpy:4 arpy:2]"\n')),(0,l.kt)("p",null,"If you use curly brackets instead of square you get a different effect. With square brackets both halves of the sequence are fitted into the cycle (polyrhythm). With curly brackets the pulse is set by the left hand pattern. The right hand pattern can then overlap (or underlap!) (polymeter):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "[voodoo voodoo:3, arpy arpy:4 arpy:2]"\nd1 $ sound "{voodoo voodoo:3, arpy arpy:4 arpy:2}"\nd1 $ sound "[drum bd hh bd, can can:2 can:3 can:4 can:2]"\nd1 $ sound "{drum bd hh bd, can can:2 can:3 can:4 can:2}"\nd1 $ sound "[bd sn, can:2 can:3 can:1, arpy arpy:1 arpy:2 arpy:3 arpy:5]"\nd1 $ sound "{bd sn, can:2 can:3 can:1, arpy arpy:1 arpy:2 arpy:3 arpy:5}"\n')),(0,l.kt)("h3",{id:"euclidean-rhythmbjorklund"},"Euclidean rhythm/Bjorklund"),(0,l.kt)("p",null,"If you give two numbers in brackets after an element in a pattern, then ",(0,l.kt)("strong",{parentName:"p"},"Tidal")," will try to distribute the first number of sounds equally across the second number of steps:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd(5,8)"\n')),(0,l.kt)("p",null,"You can use this notation within a single element of a pattern:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd(3,8) sn*2"\nd1 $ sound "bd(3,8) sn(5,8)"\n')),(0,l.kt)("p",null,"You can also add a third parameter, which \u2018rotates\u2019 the pattern so it starts on a different step:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd(5,8,2)"\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"randomness"},"Randomness"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"/docs/reference/randomness"},"Randomness")," can help us quickly introduce character and variation into our patterns. ",(0,l.kt)("inlineCode",{parentName:"p"},"sometimes")," works a bit like ",(0,l.kt)("inlineCode",{parentName:"p"},"every"),", but instead of happening after a set period, changes have a random chance of appearing:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sometimes (# speed "2") $ sound "drum*8"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"often")," (75%) works like ",(0,l.kt)("inlineCode",{parentName:"p"},"sometimes")," (50%) but happens more often:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ often (# speed "2") $ sound "drum*8"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"irand")," generates a random integer up to the number specified. (e.g. to play a random sample):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "arpy(3,8)" # n (irand 16)\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"rand")," generates a random decimal between ",(0,l.kt)("inlineCode",{parentName:"p"},"0")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"1"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "tink*16" # gain rand\n')),(0,l.kt)("p",null,"You can use ",(0,l.kt)("inlineCode",{parentName:"p"},"degradeBy")," to remove random elements. The number indicates how likely a sample is to play:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ degradeBy 0.2 $ sound "tink*16"\n')),(0,l.kt)("p",null,"(",(0,l.kt)("inlineCode",{parentName:"p"},"degrade")," on its own is the same as ",(0,l.kt)("inlineCode",{parentName:"p"},"degradeBy 0.5"),")"),(0,l.kt)("p",null,"Or, you can use ",(0,l.kt)("inlineCode",{parentName:"p"},"?")," to remove sounds with a 50% likelihood:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd sn:2? bd sn?"\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"manipulating-samples"},"Manipulating Samples"),(0,l.kt)("p",null,"So far we've just used short samples. Longer samples can cause us some problems if we\u2019re not careful. Let\u2019s see what happens with a long sample:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bev"\n-- wait a bit, then..\nhush\n')),(0,l.kt)("p",null,"As you can hear, ",(0,l.kt)("strong",{parentName:"p"},"Tidal")," will keep triggering the sample each cycle, even if it\u2019s very long. Even if you stop the pattern playing, you will still need to listen while the samples play out. You can use ",(0,l.kt)("inlineCode",{parentName:"p"},"cut")," to truncate the sample when the next one is triggered:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bev" # cut 1\n')),(0,l.kt)("p",null,"The number in ",(0,l.kt)("inlineCode",{parentName:"p"},"cut")," define a group, so you can play with interference across different patterns:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bev ~" # cut 1\nd2 $ slow 4 $ sound "pebbles ~" # cut 1\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"legato")," also truncates samples, but using a fixed length:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bev ~ bev ~" # legato 1\n')),(0,l.kt)("p",null,"We can also ",(0,l.kt)("inlineCode",{parentName:"p"},"chop")," samples for a ",(0,l.kt)("em",{parentName:"p"},"granular synthesis")," effect:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ chop 32 $ sound "bev"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"striate")," is similar to ",(0,l.kt)("inlineCode",{parentName:"p"},"chop")," but organises the playback in a different way:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 4 $ chop 4 $ sound "arpy:1 arpy:2 arpy:3 arpy:4"\nd1 $ slow 4 $ striate 4 $ sound "arpy:1 arpy:2 arpy:3 arpy:4"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"randslice")," chops the sample into pieces and then plays back a random one each cycle:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ randslice 32 $ sound "bev"\n')),(0,l.kt)("p",null,"We can also use ",(0,l.kt)("inlineCode",{parentName:"p"},"loopAt")," to fit samples to a set number of cycles:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ loopAt 8 $ sound "bev"\n')),(0,l.kt)("p",null,"As always we can add patterns and transformations to these functions, or combine them for interesting effects:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ loopAt "<8 4 16>" $ chop 64 $  sound "bev*4" # cut 1\nd1 $ rev $ loopAt 8 $ chop 128 $ sound "bev"\n')),(0,l.kt)("p",null,"See more ways to manipulate longer samples at the ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/sampling"},"Sampling reference section"),"."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"superdirt-synthesizers"},"Superdirt synthesizers"),(0,l.kt)("p",null,"So far we have used only samples, but SuperDirt also comes with many Supercollider ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/synthesizers"},"synthesizers")," like ",(0,l.kt)("inlineCode",{parentName:"p"},"superpiano"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"supersaw")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"superfm"),", also known as ",(0,l.kt)("strong",{parentName:"p"},"synths")," for short."),(0,l.kt)("p",null,"Each of them has it's own functions and parameters, but in general you can use them in a very similar way to samples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ n "0 4 7" # sound "superpiano"\n')),(0,l.kt)("p",null,"You can also control external synthesizers by ",(0,l.kt)("a",{parentName:"p",href:"/docs/configuration/MIDIOSC/midi"},"MIDI")," or ",(0,l.kt)("a",{parentName:"p",href:"/docs/configuration/MIDIOSC/osc"},"OSC")),(0,l.kt)("h3",{id:"difference-between-functions-n-and-note"},"Difference between functions ",(0,l.kt)("inlineCode",{parentName:"h3"},"n")," and ",(0,l.kt)("inlineCode",{parentName:"h3"},"note")),(0,l.kt)("p",null,"When using synths, both ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"note")," functions are exactly the same: you may have noticed that the above example plays a C note, an E note (which is 4 semitones above C), and a G note (which is 7 semitones above C). This is exactly the same as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ note "0 4 7" # sound "superpiano"\n')),(0,l.kt)("p",null,"When using samples, ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," refers to the file index in the sample folder, sorted alphabetically (ascending) and counted from 0 (zero). It is possible for each sample to correspond to a note, if you have sampled every single note of an instrument. However when using ",(0,l.kt)("inlineCode",{parentName:"p"},"note"),", the sample is pitched up or down (and the sample duration is affected accordingly)."),(0,l.kt)("p",null,"So, for example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd*4" # n "<0 4>" # note "0 12 -7 -12"\n')),(0,l.kt)("p",null,"This will play the first sample in the ",(0,l.kt)("inlineCode",{parentName:"p"},"bd")," folder on odd cycles and the fifth sample on even cycles. On each cycle, the sample will be played 4 times: one as is, one pitched an octave above (12 semitones), one a fifth below (7 semitones), and the last one an octave below."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"playing-notes"},"Playing notes"),(0,l.kt)("p",null,"Most of this tutorial is dedicated to rhythm, but ",(0,l.kt)("strong",{parentName:"p"},"Tidal Cycles")," also offers ways to play notes, scales, chords and arpeggios."),(0,l.kt)("p",null,"You already know how to play notes: using the ",(0,l.kt)("inlineCode",{parentName:"p"},"note")," function or, in case you have a per-note sampled instrument, choosing notes with the ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," function."),(0,l.kt)("p",null,"You can also write notes based on the Western Music Theory naming convention which uses the first 7 letters of the alphabet (A to G). For example, these two codes are equivalent:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ note "c a f e" # s "supermandolin"\nd1 $ note "0 9 5 4" # s "supermandolin"\n')),(0,l.kt)("p",null,"Note names are simply translated to numbers in tidal, so you can use either method, or both at the same time!"),(0,l.kt)("p",null,"Note that you can follow any note name with ",(0,l.kt)("inlineCode",{parentName:"p"},"s")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," to indicate sharp and flat respectively. Also, note that ",(0,l.kt)("inlineCode",{parentName:"p"},"0")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"c")," refer to the C note on the fifth octave. You can append the octave number following any note name:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ note "c4 a3 f6 e5" # s "supermandolin"\n')),(0,l.kt)("p",null,"It can also be useful to move the octave using ",(0,l.kt)("inlineCode",{parentName:"p"},"|+")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"|-"),". This will play on the third octave:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ note "c a f e" # s "superpiano" |- note 24\n')),(0,l.kt)("p",null,"To know more about how to play scales, chords and arpeggios, see the ",(0,l.kt)("a",{parentName:"p",href:"/docs/reference/harmony_melody"},"Harmony")," or the how-tos ",(0,l.kt)("a",{parentName:"p",href:"/docs/patternlib/howtos/buildarpeggios"},"Build Arpeggios")," and ",(0,l.kt)("a",{parentName:"p",href:"/docs/patternlib/howtos/playchords"},"Play Chords")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"where-to-go-from-here"},"Where to go from here"),(0,l.kt)("p",null,"Some suggestions:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Play, try, investigate. Here you have plenty of information to get you started. Look up the reference pages to learn more as you need it."),(0,l.kt)("li",{parentName:"ul"},"Follow ",(0,l.kt)("a",{parentName:"li",href:"/docs/patternlib/tutorials/course1"},"Alex's video course")," for a longer and deeper tutorial, with plenty of examples and video support."),(0,l.kt)("li",{parentName:"ul"},"Join the ",(0,l.kt)("a",{parentName:"li",href:"https://club.tidalcycles.org/"},"forum")," and/or the ",(0,l.kt)("a",{parentName:"li",href:"https://discord.com/invite/CqWhZEfNbq"},"discord server")," to ask for help, help others, and learn about how other people is using ",(0,l.kt)("strong",{parentName:"li"},"Tidal Cycles"),".")))}u.isMDXComponent=!0}}]);