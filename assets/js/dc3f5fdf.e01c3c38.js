"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8020],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>k});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,k=c["".concat(s,".").concat(m)]||c[m]||u[m]||l;return n?a.createElement(k,r(r({ref:t},d),{},{components:n})):a.createElement(k,r({ref:t},d))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:i,r[1]=o;for(var p=2;p<l;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1148:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=n(3117),i=(n(7294),n(3905));const l={title:"MIDI",id:"midi",permalink:"wiki/MIDI/",layout:"wiki"},r=void 0,o={unversionedId:"configuration/MIDIOSC/midi",id:"configuration/MIDIOSC/midi",title:"MIDI",description:"Tidal can send and receive MIDI messages. You can talk with external synthesizers and hardware and receive data from your controllers. All the mapping is done directly through the language in an intuitive way.",source:"@site/docs/configuration/MIDIOSC/MIDI.md",sourceDirName:"configuration/MIDIOSC",slug:"/configuration/MIDIOSC/midi",permalink:"/docs/configuration/MIDIOSC/midi",draft:!1,editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/configuration/MIDIOSC/MIDI.md",tags:[],version:"current",lastUpdatedAt:1688787386,formattedLastUpdatedAt:"Jul 8, 2023",frontMatter:{title:"MIDI",id:"midi",permalink:"wiki/MIDI/",layout:"wiki"},sidebar:"docs",previous:{title:"Adding Synthesizers",permalink:"/docs/configuration/adding_synthesizers"},next:{title:"OSC",permalink:"/docs/configuration/MIDIOSC/osc"}},s={},p=[{value:"SuperDirt MIDI",id:"superdirt-midi",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Initialization",id:"initialization",level:3},{value:"Usage in Tidal",id:"usage-in-tidal",level:3},{value:"Note Patterns",id:"note-patterns",level:4},{value:"MIDI Channels",id:"midi-channels",level:4},{value:"CC Params",id:"cc-params",level:4},{value:"Velocity",id:"velocity",level:4},{value:"Pitch modulation",id:"pitch-modulation",level:4},{value:"Aftertouch",id:"aftertouch",level:4},{value:"Modulation wheel",id:"modulation-wheel",level:4},{value:"Program change",id:"program-change",level:4},{value:"NRPN parameters",id:"nrpn-parameters",level:4},{value:"Tidal-Midi",id:"tidal-midi",level:2},{value:"Synchronising MIDI clock",id:"synchronising-midi-clock",level:2},{value:"Synchronising MIDI clock using the Link protocol",id:"synchronising-midi-clock-using-the-link-protocol",level:3},{value:"Ableton Live as the MIDI clock source",id:"ableton-live-as-the-midi-clock-source",level:4},{value:"SuperCollider as the MIDI clock source",id:"supercollider-as-the-midi-clock-source",level:4},{value:"Synchronising MIDI clock via Tidal",id:"synchronising-midi-clock-via-tidal",level:3},{value:"Controller Input",id:"controller-input",level:2},{value:"Setup",id:"setup",level:3},{value:"Usage",id:"usage",level:3},{value:"Renaming MIDI notes",id:"renaming-midi-notes",level:3},{value:"Alternative with Pure Data",id:"alternative-with-pure-data",level:3}],d={toc:p};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Tidal can send and receive MIDI messages. You can talk with external synthesizers and hardware and receive data from your controllers. All the mapping is done directly through the language in an intuitive way."),(0,i.kt)("h2",{id:"superdirt-midi"},"SuperDirt MIDI"),(0,i.kt)("h3",{id:"prerequisites"},"Prerequisites"),(0,i.kt)("p",null,"The prerequisites require recent versions of ",(0,i.kt)("strong",{parentName:"p"},"Tidal")," and ",(0,i.kt)("strong",{parentName:"p"},"SuperDirt"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Upgrade to the latest Tidal (this post assumes version 0.9.10 or greater)"),(0,i.kt)("li",{parentName:"ul"},"Make sure you have the latest ",(0,i.kt)("strong",{parentName:"li"},"SuperDirt quark"),". Uninstalling and reinstalling the SuperDirt quark might be easiest. See ",(0,i.kt)("a",{parentName:"li",href:"github.com/supercollider-quarks/quarks"},"this page")," for details on how to update Quarks.")),(0,i.kt)("h3",{id:"initialization"},"Initialization"),(0,i.kt)("p",null,"To begin, you'll start in ",(0,i.kt)("strong",{parentName:"p"},"SuperCollider"),". Start up ",(0,i.kt)("strong",{parentName:"p"},"SuperDirt")," as you normally would. Then, in SuperCollider eval the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"MIDIClient.init;\n")),(0,i.kt)("p",null,"You should now see a list of the system MIDI devices in ",(0,i.kt)("strong",{parentName:"p"},"SuperCollider"),"'s post window. The output will look something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'MIDI Sources:\n    MIDIEndPoint("LoopBe Internal MIDI", "LoopBe Internal MIDI")\n    MIDIEndPoint("Focusrite USB MIDI", "Focusrite USB MIDI")\nMIDI Destinations:\n    MIDIEndPoint("Microsoft GS Wavetable Synth", "Microsoft GS Wavetable Synth")\n    MIDIEndPoint("LoopBe Internal MIDI", "LoopBe Internal MIDI")\n    MIDIEndPoint("Focusrite USB MIDI", "Focusrite USB MIDI")\n')),(0,i.kt)("p",null,"Take note that these MIDI devices have two parts to their names. You will need both parts in the next step, which is to actually connect to the MIDI device. Eval the following line:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'~midiOut = MIDIOut.newByName("Focusrite USB MIDI", "Focusrite USB MIDI"); // substitute your own device here\n')),(0,i.kt)("p",null,"Above, we have stored a reference to the device in a variable named ",(0,i.kt)("inlineCode",{parentName:"p"},"~midiOut"),"."),(0,i.kt)("p",null,'Finally, define the name of the "synth" in Tidal you will use to control this device. Below, we will call it ',(0,i.kt)("inlineCode",{parentName:"p"},"mydevice"),". Eval the following line:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"~dirt.soundLibrary.addMIDI(\\mydevice, ~midiOut);\n")),(0,i.kt)("p",null,"Optionally, you can define a latency value on your device:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"~midiOut.latency = 0.45;\n")),(0,i.kt)("p",null,"That's it for initialization. You should now have a MIDI device connected in SuperDirt, running as a synth named ",(0,i.kt)("inlineCode",{parentName:"p"},"mydevice"),"."),(0,i.kt)("h3",{id:"usage-in-tidal"},"Usage in Tidal"),(0,i.kt)("h4",{id:"note-patterns"},"Note Patterns"),(0,i.kt)("p",null,"Now we can start writing some Tidal patterns to control the MIDI device. Let's send it a trivial note pattern:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ n "0 2 4 7" # s "mydevice"\n')),(0,i.kt)("p",null,"That should play a simple four-note pattern. Notice we're just using the synth name ",(0,i.kt)("inlineCode",{parentName:"p"},"mydevice")," to send notes to the MIDI device."),(0,i.kt)("p",null,"You can also use the note-name and octave notation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ n "c4 d4 e5 g3" # s "mydevice"\n')),(0,i.kt)("p",null,"Alternatively to using ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"note")," to pass MIDI notes, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"midinote")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"Type: midinote :: Pattern Note -> ControlPattern\n")),(0,i.kt)("p",null,"The only difference is that with ",(0,i.kt)("inlineCode",{parentName:"p"},"midinote")," notes are specified with numbers from 0 (C(-1)) to 127 (G9). In ",(0,i.kt)("strong",{parentName:"p"},"Tidal Cycles"),", note 0 is C5, and in MIDI, C5 is note 60, so it's easy to translate from one system to the other by adding or subtracting ",(0,i.kt)("inlineCode",{parentName:"p"},"60")," to the note value."),(0,i.kt)("p",null,"The last example could be rewritten as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ midinote "48 50 64 42" # s "mydevice"\n')),(0,i.kt)("h4",{id:"midi-channels"},"MIDI Channels"),(0,i.kt)("p",null,"Use the function ",(0,i.kt)("inlineCode",{parentName:"p"},"midichan")," to set the MIDI channel."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"Type: midichan :: Pattern Double -> ControlPattern\n")),(0,i.kt)("p",null,"The default MIDI channel is 1. SuperDirt MIDI channels are indexed starting at zero, so MIDI channel 1 is midichan 0:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ note "0 2 4 7" # s "mydevice" # midichan 0\n')),(0,i.kt)("p",null,"If your synth is listening on a different channel, let's say, MIDI channel 5, you would use ",(0,i.kt)("inlineCode",{parentName:"p"},"midichan 4"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ note "0 2 4 7" # s "mydevice" # midichan 4\n')),(0,i.kt)("p",null,"Notice that ",(0,i.kt)("inlineCode",{parentName:"p"},"midichan")," accepts a pattern of numbers, so you can use a pattern to play on different MIDI channels:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ note "0 2 4 7" # s "mydevice" # midichan "0 4"\n')),(0,i.kt)("p",null,'The above pattern plays notes "0 2" on channel 1 and "4 7" on channel 5.'),(0,i.kt)("h4",{id:"cc-params"},"CC Params"),(0,i.kt)("p",null,"To send a CC param to your synth, the best way to do it in the new SuperDirt MIDI is with a different Tidal pattern. To create this pattern, you'll be using two new SuperDirt MIDI params:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ccn"),": the CC param number you want to control: ",(0,i.kt)("inlineCode",{parentName:"li"},"ccn 30")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ccv"),": the value to send to the CC param, ranging from 0 to 127: ",(0,i.kt)("inlineCode",{parentName:"li"},"ccv 64"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"Type: ccn :: Pattern Double -> ControlPattern\nType: ccv :: Pattern Double -> ControlPattern\n")),(0,i.kt)("p",null,"Here's a full example, sending a value of 64 to CC param 30:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d2 $ ccv 64 # ccn 30 # s "mydevice"\n')),(0,i.kt)("p",null,"You can of course also specify the MIDI channel with ",(0,i.kt)("inlineCode",{parentName:"p"},"midichan"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d2 $ ccv 64 # ccn 30 # s "mydevice" # midichan 4\n')),(0,i.kt)("p",null,"You can specify patterns of CC values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d2 $ ccv "20 40 60 80 100" # ccn 30 # s "mydevice"\n\nd2 $ ccn "30*4" # ccv (range 20 100 $ slow 30 sine) # s "mydevice"\n')),(0,i.kt)("p",null,"Note that the left-most pattern defines the rhythm in this case when using ",(0,i.kt)("inlineCode",{parentName:"p"},"#"),"."),(0,i.kt)("p",null,"If you have a specific feature on your device that listens on a specific CC number, you can give it a friendly name if you wish:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'let ringMod = 30\nd2 $ ccv "0 20 50 60" # ccn ringMod # s "mydevice"\n')),(0,i.kt)("p",null,"If you have many CC params you want to control at once, a stack works well:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'d2 $ fast 8 $ stack [\n  ccn 30 # ccv (range 0 127 $ slow 30 sine),\n  ccn 31 # ccv "[0 70 30 110]/3",\n  ccn 32 # ccv 10\n  ] # s "mydevice"\n')),(0,i.kt)("p",null,"Each device has its own MIDI chart implementation, but there are a few CC numbers that are standard and should work the same in most devices:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"CC number"),(0,i.kt)("th",{parentName:"tr",align:null},"Function"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"Modulation wheel")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"Breath controller")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"7"),(0,i.kt)("td",{parentName:"tr",align:null},"Volume")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"10"),(0,i.kt)("td",{parentName:"tr",align:null},"Pan")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"11"),(0,i.kt)("td",{parentName:"tr",align:null},"Expression pedal")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"64"),(0,i.kt)("td",{parentName:"tr",align:null},"Sustain pedal (<=63 Off, >=64 On)")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"Type: cc :: Pattern String -> ControlPattern\n")),(0,i.kt)("p",null,"There is also the function ",(0,i.kt)("inlineCode",{parentName:"p"},"cc"),", which allows us to pass both the number and the value in a single string:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d2 $ cc "64:30" # s "mydevice" # midichan 4\n')),(0,i.kt)("h4",{id:"velocity"},"Velocity"),(0,i.kt)("p",null,"MIDI velocity can be set using ",(0,i.kt)("inlineCode",{parentName:"p"},"amp")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"gain"),". They work in a similar way to when used with samples, being ",(0,i.kt)("inlineCode",{parentName:"p"},"amp")," linear and ",(0,i.kt)("inlineCode",{parentName:"p"},"gain")," exponential."),(0,i.kt)("p",null,"Default velocity is ",(0,i.kt)("inlineCode",{parentName:"p"},"50"),", default ",(0,i.kt)("inlineCode",{parentName:"p"},"amp")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"0.4")," and default ",(0,i.kt)("inlineCode",{parentName:"p"},"gain")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,i.kt)("p",null,"In the following tables you can see how distinct ",(0,i.kt)("inlineCode",{parentName:"p"},"amp")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"gain")," values affect velocity:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Amp value"),(0,i.kt)("th",{parentName:"tr",align:"center"},"MIDI velocity value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.1"),(0,i.kt)("td",{parentName:"tr",align:"center"},"12")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.2"),(0,i.kt)("td",{parentName:"tr",align:"center"},"25")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.3"),(0,i.kt)("td",{parentName:"tr",align:"center"},"38")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.4"),(0,i.kt)("td",{parentName:"tr",align:"center"},"50")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.5"),(0,i.kt)("td",{parentName:"tr",align:"center"},"63")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.6"),(0,i.kt)("td",{parentName:"tr",align:"center"},"76")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.7"),(0,i.kt)("td",{parentName:"tr",align:"center"},"88")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.8"),(0,i.kt)("td",{parentName:"tr",align:"center"},"101")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.9"),(0,i.kt)("td",{parentName:"tr",align:"center"},"114")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"1"),(0,i.kt)("td",{parentName:"tr",align:"center"},"127")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Gain value"),(0,i.kt)("th",{parentName:"tr",align:"center"},"MIDI velocity value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"<=0.3"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.4"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.5"),(0,i.kt)("td",{parentName:"tr",align:"center"},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.6"),(0,i.kt)("td",{parentName:"tr",align:"center"},"6")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.7"),(0,i.kt)("td",{parentName:"tr",align:"center"},"12")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.8"),(0,i.kt)("td",{parentName:"tr",align:"center"},"20")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"0.9"),(0,i.kt)("td",{parentName:"tr",align:"center"},"33")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"1"),(0,i.kt)("td",{parentName:"tr",align:"center"},"50")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"1.1"),(0,i.kt)("td",{parentName:"tr",align:"center"},"74")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"1.2"),(0,i.kt)("td",{parentName:"tr",align:"center"},"105")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},">=1.3"),(0,i.kt)("td",{parentName:"tr",align:"center"},"127")))),(0,i.kt)("h4",{id:"pitch-modulation"},"Pitch modulation"),(0,i.kt)("p",null,"Pitch modulation can be controlled using the ",(0,i.kt)("inlineCode",{parentName:"p"},"midibend")," function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"Type: midibend :: Pattern Double -> ControlPattern\n")),(0,i.kt)("p",null,"Note that usually a pitch wheel sends a number between ",(0,i.kt)("inlineCode",{parentName:"p"},"-8192")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"8191"),", but here all numbers are positive, so the range is from ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"16383"),", being ",(0,i.kt)("inlineCode",{parentName:"p"},"8192")," the neutral middle point."),(0,i.kt)("p",null,"You can simulate the movement of the pitch wheel in various ways."),(0,i.kt)("p",null,"Supposing your device is called ",(0,i.kt)("inlineCode",{parentName:"p"},"mydevice")," and receives MIDI messages on channel ",(0,i.kt)("inlineCode",{parentName:"p"},"5"),", in this example the sound will start in a C note, and gradually increase pitch to the limit of the pitch bend modulation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ stack [\n  midibend (segment 128 $ range 8193 16383 $ saw),\n  note "c"\n  ] # s "mydevice" # midichan 4\n')),(0,i.kt)("p",null,"Now, we start at the minimum of the pitch bend modulation, and move fast to the neutral point, where we will sustain the pitch for the remaining of the cycle:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ stack [\n  midibend (smooth "0@2 8193@10 8193@0.1"),\n  note "c"\n  ] # s "mydevice" # midichan 4\n')),(0,i.kt)("h4",{id:"aftertouch"},"Aftertouch"),(0,i.kt)("p",null,"Aftertouch is used to modify the character of a sound that is already playing, usually by applying more or less pressure on a MIDI controller keyboard keys."),(0,i.kt)("p",null,"To pass aftertouch MIDI messages to a device, use the function ",(0,i.kt)("inlineCode",{parentName:"p"},"miditouch"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"Type: miditouch :: Pattern Double -> ControlPattern\n")),(0,i.kt)("p",null,"Aftertouch has a range from ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"127"),", and default value is ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ stack [\n  miditouch (segment 128 $ fast 4 $ range 0 64 $ sine),\n  note "c"\n  ] # s "mydevice" # midichan 4\n')),(0,i.kt)("p",null,"In this example, once a note is playing, we set aftertouch from ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"64")," and backwards several times in a cycle, as if we were pressing the C key of a MIDI controller."),(0,i.kt)("h4",{id:"modulation-wheel"},"Modulation wheel"),(0,i.kt)("p",null,"There isn't a specific function to send modulation wheel messages, but CC ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," is used for modulation wheel, so we can use that:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ stack [\n  ccv (segment 128 $ range 0 128 $ sine) # ccn 1,\n  note "c"\n  ] # s "mydevice" # midichan 4\n')),(0,i.kt)("p",null,"Here, we start the cycle with mod wheel set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", go up to maximum, then down to the minimum, and end the cycle at ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," again."),(0,i.kt)("h4",{id:"program-change"},"Program change"),(0,i.kt)("p",null,"Program change messages can be sent with the ",(0,i.kt)("inlineCode",{parentName:"p"},"progNum")," function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"Type: progNum :: Pattern Double -> ControlPattern\n")),(0,i.kt)("p",null,"If you called you device ",(0,i.kt)("inlineCode",{parentName:"p"},"mydevice"),", and it's receiving program change messages through MIDI channel ",(0,i.kt)("inlineCode",{parentName:"p"},"14"),", you can change it's program/pattern by issuing a command like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'once $ s "mydevice" # progNum 10 # midichan 13\n')),(0,i.kt)("h4",{id:"nrpn-parameters"},"NRPN parameters"),(0,i.kt)("p",null,"To send NRPN parameters, use functions ",(0,i.kt)("inlineCode",{parentName:"p"},"nrpnn")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"nrpnv"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"Type: nrpnn :: Pattern Int -> ControlPattern\nType: nrpnv :: Pattern Int -> ControlPattern\n")),(0,i.kt)("p",null,"NRPN numbers are composed of two bytes: MSB (Most Significant Byte) and LSB (Less Significant Byte). When using ",(0,i.kt)("inlineCode",{parentName:"p"},"nrpnn"),", you write those two bytes in a single number. To calculate the number you have to use, multiply the first byte (MSB) by ",(0,i.kt)("inlineCode",{parentName:"p"},"128"),", and then add the second byte (LSB). For example, if your device manual says that reverb send is set by NRPN MSP 2 and NRPN LSB 6 (or 2:6), you need to give ",(0,i.kt)("inlineCode",{parentName:"p"},"nrpnn")," a ",(0,i.kt)("inlineCode",{parentName:"p"},"2*128+6=262"),"."),(0,i.kt)("p",null,"NRPN values also have two bytes, which allows for more precision than CC messages. The valid rang for ",(0,i.kt)("inlineCode",{parentName:"p"},"nrpnv")," is from ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"16384"),". However, note that many devices will just ignore this extra precision."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d2 $ nrpnn (2*128+6) # nrpnv 14000 # s "mydevice" # midichan 12\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"nrpnn")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"nrpnv")," are patternable, but notice that their argument is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern Int"),", so you have to make sure to pass them ",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),"s and not ",(0,i.kt)("inlineCode",{parentName:"p"},"Double"),"s:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d2 $ nrpnv (segment 32 $ floor <$> range 0 16000 sine) # nrpnn (1*128+29) # s "mydevice" # midichan 4\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sine")," is giving us ",(0,i.kt)("inlineCode",{parentName:"p"},"Double"),"s, so we need to convert them to ",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),"s before feeding them to ",(0,i.kt)("inlineCode",{parentName:"p"},"nrpnv"),". We do this by using ",(0,i.kt)("inlineCode",{parentName:"p"},"floor"),", which is a Haskell function that rounds down a number, and ",(0,i.kt)("inlineCode",{parentName:"p"},"<$>")," which applies a function (in this case ",(0,i.kt)("inlineCode",{parentName:"p"},"floor"),") to all the elements in a collection."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"Type: nrpn :: Pattern String -> ControlPattern\n")),(0,i.kt)("p",null,"There is also the function ",(0,i.kt)("inlineCode",{parentName:"p"},"nrpn"),", which allows us to pass both the number and the value in a single string:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d2 $ nrpn "262:14000" # s "mydevice" # midichan 12\n')),(0,i.kt)("h2",{id:"tidal-midi"},"Tidal-Midi"),(0,i.kt)("p",null,"The older ",(0,i.kt)("inlineCode",{parentName:"p"},"tidal-midi")," Haskell module is not currently working (although it might return). Use the other existing solutions."),(0,i.kt)("h2",{id:"synchronising-midi-clock"},"Synchronising MIDI clock"),(0,i.kt)("p",null,"It is often important to send MIDI clock events to synchronize tempo between devices.\nTidal can't sync its tempo to MIDI clock events that it receives, but it can act as a MIDI clock source.\nThe following sections show two alternatives for sending MIDI clock events that follow the tempo of Tidal."),(0,i.kt)("h3",{id:"synchronising-midi-clock-using-the-link-protocol"},"Synchronising MIDI clock using the Link protocol"),(0,i.kt)("p",null,"Since version 1.9, Tidal uses the Link protocol for scheduling events.\nLink is a technology that synchronizes musical beat, tempo, and phase across multiple applications. It was originally developed by a company called Ableton, but is open source and now implemented in a wide range of music software.\nWe can use Link to synchronize Tidal with a separate program that will act as the MIDI clock source."),(0,i.kt)("p",null,"This is the preferred method for sending MIDI clock events as it is easy, performant, stable, and has fewer quirks than ",(0,i.kt)("a",{parentName:"p",href:"#synchronising-midi-clock-via-tidal"},"Synchronising MIDI clock via Tidal"),"."),(0,i.kt)("h4",{id:"ableton-live-as-the-midi-clock-source"},"Ableton Live as the MIDI clock source"),(0,i.kt)("p",null,"Ableton Live can synchronize with Tidal over Link and simultaneously send MIDI clock messages."),(0,i.kt)("p",null,"To achieve this, follow both instructions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Turn on Link sync in Ableton Live. See ",(0,i.kt)("a",{parentName:"li",href:"https://www.ableton.com/en/manual/synchronizing-with-link-tempo-follower-and-midi/#32-1-synchronizing-via-link"},"Synchronizing via Link"),"."),(0,i.kt)("li",{parentName:"ul"},"Turn the MIDI device on as a sync destination in Live\u2019s Link/Tempo/MIDI Preferences. See ",(0,i.kt)("a",{parentName:"li",href:"https://www.ableton.com/en/manual/synchronizing-with-link-tempo-follower-and-midi/#32-3-1-synchronizing-external-midi-devices-to-live"},"Synchronizing External MIDI Devices to Live"),".")),(0,i.kt)("h4",{id:"supercollider-as-the-midi-clock-source"},"SuperCollider as the MIDI clock source"),(0,i.kt)("p",null,"We can use Link to synchronize Tidal with SuperCollider and set up SuperCollider to send MIDI clock events. This method was inspired by ",(0,i.kt)("a",{parentName:"p",href:"https://scsynth.org/t/midi-clock-out-separate-process-for-better-stability/5089"},"jamshark70's thread"),". This requires extending SuperCollider with a new class ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkToMidiClock"),"."),(0,i.kt)("p",null,"First decide if the SuperCollider class should be available only to your user account or to all users on the machine. Then find the corresponding extensions directory by running one of these lines in SuperCollider:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-supercollider"},"Platform.userExtensionDir;   // Extensions available only to your user account\nPlatform.systemExtensionDir; // Extensions available to all users on the machine\n")),(0,i.kt)("p",null,"Create a file ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkToMidiClock.sc")," in the selected extensions directory and save it with this content:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-supercollider"},'LinkToMidiClock {\n    var <midiOut, <linkClock, routine, <isPlaying = false, d;\n\n    *new { arg midiOut, linkClock;\n        ^super.newCopyArgs(midiOut, linkClock)\n    }\n\n    start {\n        if(isPlaying,{\n            "Can\'t start. LinkToMidiClock is already playing".inform;\n        },{\n            isPlaying = true;\n            d = 1/24;\n            routine = Routine {\n                midiOut.start;\n                loop {\n                    23.do { |i|\n                        midiOut.midiClock;\n                        d.wait;\n                    };\n                    midiOut.midiClock;\n                    (thisThread.clock.beats.ceil - thisThread.beats).wait;\n                }\n            }.play(linkClock, [linkClock.quantum, 0]);\n        });\n    }\n\n    stop {\n        if(isPlaying,{\n            isPlaying = false;\n            midiOut.stop;\n            routine.stop;\n        },{\n            "Can\'t stop. LinkToMidiClock is not playing".inform;\n        })\n    }\n}\n')),(0,i.kt)("p",null,"Reboot SuperCollider or use ",(0,i.kt)("inlineCode",{parentName:"p"},"Language > Recompile Class Library"),"."),(0,i.kt)("p",null,"We are now ready to follow the ",(0,i.kt)("a",{parentName:"p",href:"#Initialization"},"initialization")," guide. We will use the MIDI device variable named ",(0,i.kt)("inlineCode",{parentName:"p"},"~midiOut")," from the initialization in the examples below."),(0,i.kt)("p",null,"After the MIDI device is initialized, create a ",(0,i.kt)("a",{parentName:"p",href:"https://doc.sccode.org/Classes/LinkClock.html"},"LinkClock")," in SuperCollider."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-supercollider"},"~lc = LinkClock.new.latency_(Server.default.latency);\n")),(0,i.kt)("p",null,"You can check that Tidal and SuperCollider have connected over Link by checking the number of Link peers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"~lc.numPeers; '0 means no connection, 1 means connection\n")),(0,i.kt)("p",null,"Then, create a ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkToMidiClock")," that is connected to the MIDI device ",(0,i.kt)("inlineCode",{parentName:"p"},"~midiOut")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkClock")," ",(0,i.kt)("inlineCode",{parentName:"p"},"~lc"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-supercollider"},"~ltmc = LinkToMidiClock(~midiOut, ~lc);\n")),(0,i.kt)("p",null,"MIDI clock events will be sent continously after we tell it to start, until we tell it to stop."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-supercollider"},"~ltmc.start;\n~ltmc.stop;\n")),(0,i.kt)("p",null,"Note: If SuperCollider and Tidal don't connect over Link, try starting Tidal before the LinkClock is created, but after SuperDirt is started. Alternatively, try creating the LinkClock before starting Tidal. This has anecdotally worked in some cases. Please report your findings in ",(0,i.kt)("a",{parentName:"p",href:"https://club.tidalcycles.org/t/tidalcycles-version-1-9-0/4292"},"the TidalCycles version 1.9.0 nnouncement thread"),"."),(0,i.kt)("p",null,"For more details on Tidal's integration with Link, see ",(0,i.kt)("a",{parentName:"p",href:"../multiuser-tidal#link-protocol-synchronization"},"Multi-User Tidal"),"."),(0,i.kt)("h3",{id:"synchronising-midi-clock-via-tidal"},"Synchronising MIDI clock via Tidal"),(0,i.kt)("p",null,"We can alternatively use Tidal and ",(0,i.kt)("strong",{parentName:"p"},"SuperDirt MIDI")," for sending MIDI clock events. The advantage is that it also works in older versions of Tidal, but the method is somewhat more complicated."),(0,i.kt)("p",null,"Set up ",(0,i.kt)("strong",{parentName:"p"},"SuperDirt MIDI")," by following the ",(0,i.kt)("a",{parentName:"p",href:"#Initialization"},"initialization")," guide."),(0,i.kt)("p",null,"When that is done, you can start sending MIDI clock messages, 48 per cycle, like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'p "midiclock" $ midicmd "midiClock*48" # s "mydevice"\n')),(0,i.kt)("p",null,"Your MIDI device should adjust its BPM to Tidal's cps. It's then a good idea to send a ",(0,i.kt)("inlineCode",{parentName:"p"},"stop")," message like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'once $ midicmd "stop" # s "mydevice"\n')),(0,i.kt)("p",null,"and then finally a start message to start the MIDI clock at the right time. The following sends a start message every fourth cycle:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'p "midictl" $ midicmd "start/4" # s "mydevice"\n\n')),(0,i.kt)("p",null,"Once everything's started and in sync, it's probably best to stop sending the start messages to avoid glitching:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'p "midictl" $ silence\n')),(0,i.kt)("p",null,"However now if you do hush, the ",(0,i.kt)("inlineCode",{parentName:"p"},"midiclock")," will stop as well as all the other patterns. To avoid this, you can overwrite the hush function with a version that silences particular patterns:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"let hush = mapM_ ($ silence) [d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16]\n")),(0,i.kt)("p",null,"You will probably find that the downbeats for SuperDirt and your MIDI devices don't align. As a starting point, set MIDI latency in supercollider to 0:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-supercollider"},"~midiOut.latency = 0;\n")),(0,i.kt)("p",null,"Make sure any offset on the MIDI side is also set to 0, then gradually adjust one of them until they align. If they stay in alignment when you change the cps, all is good!"),(0,i.kt)("h2",{id:"controller-input"},"Controller Input"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Tidal")," 1.0.0 now has support for external input, using the OSC protocol. Here's a quick guide to getting it going, including using a simple 'bridge' for getting MIDI input working."),(0,i.kt)("h3",{id:"setup"},"Setup"),(0,i.kt)("p",null,"To use MIDI, you don't have to worry too much about mapping OSC. However, you do have to run something to convert MIDI into OSC (",(0,i.kt)("strong",{parentName:"p"},"Tidal")," is listening for OSC messages). Here's how to do that using SuperCollider. First, with ",(0,i.kt)("strong",{parentName:"p"},"Tidal")," and ",(0,i.kt)("strong",{parentName:"p"},"SuperDirt")," already running, run the below code block in ",(0,i.kt)("strong",{parentName:"p"},"SuperCollider"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Evaluate the block below to start the mapping MIDI -> OSC.\n(\nvar on, off, cc;\nvar osc;\n\nosc = NetAddr.new("127.0.0.1", 6010);\n\nMIDIClient.init;\nMIDIIn.connectAll;\n\non = MIDIFunc.noteOn({ |val, num, chan, src|\n    osc.sendMsg("/ctrl", num.asString, val/127);\n});\n\noff = MIDIFunc.noteOff({ |val, num, chan, src|\n    osc.sendMsg("/ctrl", num.asString, 0);\n});\n\ncc = MIDIFunc.cc({ |val, num, chan, src|\n    osc.sendMsg("/ctrl", num.asString, val/127);\n});\n\nif (~stopMidiToOsc != nil, {\n    ~stopMidiToOsc.value;\n});\n\n~stopMidiToOsc = {\n    on.free;\n    off.free;\n    cc.free;\n};\n)\n\n// Evaluate the line below to stop it.\n~stopMidiToOsc.value;\n')),(0,i.kt)("h3",{id:"usage"},"Usage"),(0,i.kt)("p",null,"You should then be able to run a pattern such as the following, that uses ",(0,i.kt)("inlineCode",{parentName:"p"},"CC value 12"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd" # speed (cF 1 "12")\n')),(0,i.kt)("p",null,"If you want to use MIDI in a pattern forming statement, you may find it helpful to ",(0,i.kt)("inlineCode",{parentName:"p"},"segment")," the input first, as the raw pattern coming from your MIDI device will be at very high resolution. This example takes only one value per cycle & remaps the value with the ",(0,i.kt)("inlineCode",{parentName:"p"},"range")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "amencutup" + n (run (segment 1 $ range 1 16 $ cN 0 "32" ))\n')),(0,i.kt)("h3",{id:"renaming-midi-notes"},"Renaming MIDI notes"),(0,i.kt)("p",null,"In case you have a MIDI drum machine, where the bassdrum is on MIDI note 231 and you don't want to write ",(0,i.kt)("inlineCode",{parentName:"p"},"231")," every time, you could either do this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'s2n :: String -> Note\ns2n "BD" = 231\ns2n _ = 0\n\nd1 $ n (s2n <$> "BD*4") # sound "tr8" # midichan 9\n')),(0,i.kt)("p",null,"Another approach is using ",(0,i.kt)("inlineCode",{parentName:"p"},"inhabit"),", you pass it a list of names and patterns, like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'let drum pat = sound (inhabit [("bd", "231"), ("sd", "232")] pat)\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ drum "bd sd" # midichan 9\n')),(0,i.kt)("p",null,"You could also hide the midi channel in there so you don't have to type it each time"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'let drum pat = sound (inhabit [("bd", "231"), ("sd", "232")] pat) # midichan 9\n\nd1 $ drum "bd sd"\nd2 $ drum "bd*3 sd*2"\n')),(0,i.kt)("p",null,"Note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"232")," bit is a pattern, so you could have one name trigger more than one event e.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'let drum pat = sound (inhabit [("bd", "231"), ("rush", "232*8"), ("sd", "232")] pat) # midichan 9\n\nd1 $ drum "bd sd rush"\n')),(0,i.kt)("h3",{id:"alternative-with-pure-data"},"Alternative with Pure Data"),(0,i.kt)("p",null,"The above ",(0,i.kt)("strong",{parentName:"p"},"SuperCollider")," instructions are most convenient if you're using ",(0,i.kt)("strong",{parentName:"p"},"SuperDirt"),", but as an alternative you can use ",(0,i.kt)("strong",{parentName:"p"},"Pure Data")," to convert midi to ",(0,i.kt)("strong",{parentName:"p"},"OSC"),". You can get puredata from ",(0,i.kt)("a",{parentName:"p",href:"https://puredata.info/"},"here")," (the ",(0,i.kt)("inlineCode",{parentName:"p"},"vanilla")," version is recommended). Then, download ",(0,i.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/tidalcycles/Tidal/main/pd/midi-osc-bridge.pd"},"this file"),". Then if you start ",(0,i.kt)("strong",{parentName:"p"},"Tidal"),", open that file in ",(0,i.kt)("strong",{parentName:"p"},"Pure Data"),", and configure your ",(0,i.kt)("strong",{parentName:"p"},"MIDI")," device in ",(0,i.kt)("strong",{parentName:"p"},"Pure Data"),", things should start working."))}c.isMDXComponent=!0}}]);