(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{190:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return i})),n.d(t,"default",(function(){return c}));var a=n(3),r=n(7),l=(n(0),n(309)),o={title:"Sampling",id:"sampling"},s={unversionedId:"reference/sampling",id:"reference/sampling",isDocsHomePage:!1,title:"Sampling",description:"This page will present you all the functions that can be used to slice, cut, reverse or explode your audio samples, incoming signals or oscillators. Each function will be presented following the same model:",source:"@site/docs/reference/sampling.md",slug:"/reference/sampling",permalink:"/docs/reference/sampling",editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/reference/sampling.md",version:"current",lastUpdatedBy:"Raphael Forment",lastUpdatedAt:1621864783,sidebar:"reference",previous:{title:"Transitions",permalink:"/docs/reference/transitions"},next:{title:"Randomness",permalink:"/docs/reference/randomness"}},i=[{value:"Audio sampling",id:"audio-sampling",children:[{value:"chop",id:"chop",children:[]},{value:"striate",id:"striate",children:[]},{value:"striateBy",id:"striateby",children:[]},{value:"loopAt",id:"loopat",children:[]}]},{value:"Signal sampling",id:"signal-sampling",children:[{value:"segment",id:"segment",children:[]},{value:"discretise",id:"discretise",children:[]}]}],p={toc:i};function c(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,"This page will present you all the functions that can be used to slice, cut, reverse or explode your audio samples, incoming signals or oscillators. Each function will be presented following the same model:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Type signature"),": how the function is declared on the ",Object(l.b)("strong",{parentName:"li"},"Haskell")," side."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Description"),": verbal description of the function."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Examples"),": a small list of examples that you can copy/paste in your editor.")),Object(l.b)("h2",{id:"audio-sampling"},"Audio sampling"),Object(l.b)("h3",{id:"chop"},"chop"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},"Type: chop :: Pattern Int -> ControlPattern -> ControlPattern\n")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"chop")," cuts each sample into the given number of parts, allowing you to explore a technique known as 'granular synthesis'. It turns a pattern of samples into a pattern of parts of samples. For example:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ chop 16 $ sound "arpy ~ feel*2 newnotes"\n')),Object(l.b)("p",null,"In the above, each sample is chopped into 16 bits, resulting in 64 (16*4) events. You can pattern that first parameter:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ chop "<16 128 32>" $ sound "arpy ~ feel*2 newnotes"\n')),Object(l.b)("p",null,"You end up with a pattern of the chopped up bits of samples. You'll already be able to hear this more clearly if you for example reverse the pattern, as you'll reverse the order of the sample parts:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 2 $ rev $ chop 16 $ sound "breaks125"\n')),Object(l.b)("p",null,"Lets try that reverse in just one speaker:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 2 $ jux rev $ chop 16 $ sound "breaks125"\n')),Object(l.b)("p",null,"Different values of ",Object(l.b)("inlineCode",{parentName:"p"},"chop")," can yield very different results, depending on the samples used:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ chop 16 $ sound (samples "arpy*8" (run 16))\nd1 $ chop 32 $ sound (samples "arpy*8" (run 16))\nd1 $ chop 256 $ sound "bd*4 [sn cp] [hh future]*2 [cp feel]"\n')),Object(l.b)("p",null,"You can also use ",Object(l.b)("inlineCode",{parentName:"p"},"chop")," (or ",Object(l.b)("inlineCode",{parentName:"p"},"striate"),") with very long samples, to cut it into short chunks and pattern those chunks. The following cuts a sample into 32 parts, and plays it over 8 cycles:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ loopAt 8 $ chop 32 $ sound "bev"\n')),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"loopAt")," takes care of changing the speed of sample playback so that the sample fits in the given number of cycles perfectly. As a result, in the above the granules line up perfectly, so you can\u2019t really hear that the sample has been cut into bits. Again, this becomes more apparent when you do further manipulations of the pattern, for example ",Object(l.b)("inlineCode",{parentName:"p"},"rev")," to reverse the order of the cut up bits:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ loopAt 8 $ rev $ chop 32 $ sound "bev"\n')),Object(l.b)("h3",{id:"striate"},"striate"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},"Type: striate :: Pattern Int -> ControlPattern -> ControlPattern\n")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"striate")," is a kind of granulator, cutting samples into bits in a similar to ",Object(l.b)("inlineCode",{parentName:"p"},"chop"),", but the resulting bits are organised differently. For example:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 4 $ striate 3 $ sound "numbers:0 numbers:1 numbers:2 numbers:3"\n')),Object(l.b)("p",null,"This plays the loop the given number of times, but triggering progressive portions of each sample. So in this case it plays the loop three times, the first time playing the first third of each sample, then the second time playing the second third of each sample, and then finally the last third of each sample.. Compare this with ",Object(l.b)("inlineCode",{parentName:"p"},"chop"),":"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 4 $ chop 3 $ sound "numbers:0 numbers:1 numbers:2 numbers:3"\n')),Object(l.b)("p",null,"You can hear that the striate version 'interlaces' the cut up bits of samples together, whereas the chop version plays the bits from each chopped up sample in turn. It might be worth listening to the samples without granulation, in case that helps understand what\u2019s happening in the above:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 4 $ sound "numbers:0 numbers:1 numbers:2 numbers:3"\n')),Object(l.b)("h3",{id:"striateby"},"striateBy"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},"Type: striateBy :: Pattern Int -> Pattern Double -> ControlPattern -> ControlPattern\n")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"striateBy")," (formerly called ",Object(l.b)("inlineCode",{parentName:"p"},"striate'"),") is a variant of ",Object(l.b)("inlineCode",{parentName:"p"},"striate"),", with an extra parameter, which specifies the length of each part. ",Object(l.b)("inlineCode",{parentName:"p"},"striate")," still scans across the sample over a single cycle, but if each bit is longer, it creates a sort of stuttering effect. For example the following will cut the bev sample into 32 parts, but each will be 1/16th of a sample long:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ slow 32 $ striateBy 32 (1/16) $ sound "bev"\n')),Object(l.b)("p",null,"Note that striate uses the ",Object(l.b)("inlineCode",{parentName:"p"},"begin")," and ",Object(l.b)("inlineCode",{parentName:"p"},"end")," parameters internally. This means that if you\u2019re using ",Object(l.b)("inlineCode",{parentName:"p"},"striate")," or ",Object(l.b)("inlineCode",{parentName:"p"},"striateBy")," you probably shouldn\u2019t also specify begin or end."),Object(l.b)("h3",{id:"loopat"},"loopAt"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},"Type: loopAt :: Pattern Time -> ControlPattern -> ControlPattern\n")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"loopAt"),' makes sample fit the given number of cycles. Internally, it works by setting the unit control to "c", changing the playback speed of the sample with the speed parameter, and setting the density of the pattern to match.'),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ loopAt 4 $ sound "breaks125"\n')),Object(l.b)("p",null,"It\u2019s a good idea to use this in conjuction with ",Object(l.b)("inlineCode",{parentName:"p"},"chop"),", so the break is chopped into pieces and you don\u2019t have to wait for the whole sample to start/stop."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ loopAt 4 $ chop 32 $ sound "breaks125"\n')),Object(l.b)("p",null,"Like all ",Object(l.b)("strong",{parentName:"p"},"Tidal")," functions, you can mess about with this considerably. The below example shows how you can supply a pattern of cycle counts to ",Object(l.b)("inlineCode",{parentName:"p"},"loopAt"),":"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ juxBy 0.6 (|* speed "2") $ loopAt "<4 6 2 3>" $ chop 12 $ sound "fm:14"\n')),Object(l.b)("h2",{id:"signal-sampling"},"Signal sampling"),Object(l.b)("h3",{id:"segment"},"segment"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},"Type: segment :: Pattern Time -> Pattern a -> Pattern a\n")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"segment")," 'samples' the pattern at a rate of ",Object(l.b)("inlineCode",{parentName:"p"},"n")," events per cycle. Useful for turning a continuous pattern into a discrete one. In this example, the pattern originates from the shape of a sine wave, a continuous pattern. Without segment the samples will get triggered at an undefined frequency which may be very high."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ n (slow 2 $ segment 16 $ range 0 32 $ sine) # sound "amencutup"\n')),Object(l.b)("h3",{id:"discretise"},"discretise"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"segment")," used to be known as ",Object(l.b)("inlineCode",{parentName:"p"},"discretise"),". The old name remains as an alias and will still work, but may be removed or repurposed in a future version of ",Object(l.b)("strong",{parentName:"p"},"Tidal"),". "))}c.isMDXComponent=!0},309:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),c=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=c(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,o=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),b=c(n),m=a,d=b["".concat(o,".").concat(m)]||b[m]||u[m]||l;return n?r.a.createElement(d,s(s({ref:t},p),{},{components:n})):r.a.createElement(d,s({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var p=2;p<l;p++)o[p]=n[p];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);