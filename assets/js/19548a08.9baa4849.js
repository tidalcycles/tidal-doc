"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8388],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),h=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=h(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=h(n),p=i,m=c["".concat(l,".").concat(p)]||c[p]||u[p]||o;return n?a.createElement(m,r(r({ref:t},d),{},{components:n})):a.createElement(m,r({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,r[1]=s;for(var h=2;h<o;h++)r[h]=n[h];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9242:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>h});var a=n(3117),i=(n(7294),n(3905));const o={title:"How Link became Tidal's scheduler",date:new Date("2023-05-19T00:00:00.000Z")},r=void 0,s={permalink:"/blog/link_as_scheduler",editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/blog/blog/link_as_scheduler.md",source:"@site/blog/link_as_scheduler.md",title:"How Link became Tidal's scheduler",description:"Introduction",date:"2023-05-19T00:00:00.000Z",formattedDate:"May 19, 2023",tags:[],hasTruncateMarker:!1,authors:[],frontMatter:{title:"How Link became Tidal's scheduler",date:"2023-05-19T00:00:00.000Z"},prevItem:{title:"Tidal Profile - Eloi el Bon Noi (Eloi the good guy)",permalink:"/blog/tidal_profile_Eloi_el_Bon_Noi"},nextItem:{title:"Prepared Code with ghostchamb3r",permalink:"/blog/blog_topic_ghostchamb3r"}},l={authorsImageUrls:[]},h=[{value:"Introduction",id:"introduction",level:2},{value:"The idea",id:"the-idea",level:2},{value:"I get started",id:"i-get-started",level:2},{value:"Challenges",id:"challenges",level:2},{value:"Link and Tidal integration: Architecture Overview",id:"link-and-tidal-integration-architecture-overview",level:2},{value:"Tidal Innards",id:"tidal-innards",level:3},{value:"Link Concepts",id:"link-concepts",level:3},{value:"Calling the Link API from Haskell",id:"calling-the-link-api-from-haskell",level:4},{value:"Ticks and Processing Ahead",id:"ticks-and-processing-ahead",level:3},{value:"Putting it together",id:"putting-it-together",level:3},{value:"A note about multithreading",id:"a-note-about-multithreading",level:3},{value:"Final words",id:"final-words",level:2},{value:"References",id:"references",level:2}],d={toc:h};function c(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Hello, I'm Pierre Krafft, aka Zalastax, a software engineer and hobby-musician from Gothenburg, Sweden. I've been enjoying Tidal since late 2021 after first dabbling a bit with Orca and, way before that, Sonic Pi. I primarily use Tidal to control hardware synthesizers using MIDI. Tidal is a really neat sequencer and I think there's a lot of untapped potential which I hope to explore more in the future."),(0,i.kt)("p",null,"This post shares my experience of replacing a significant part of the Tidal internals.\nWhat I achieved is a direct integration from Tidal with Link,\nwhich is a library for synchronizing musical time between applications."),(0,i.kt)("p",null,"In this post, I'll explain why Link integration was important to me,\nprovide an introduction to Tidal internals (with a focus on scheduling),\nsome important concepts of Link,\nand how I overcame some really tough challenges!"),(0,i.kt)("h2",{id:"the-idea"},"The idea"),(0,i.kt)("p",null,"I make music with friends who use traditional synth setups.\nTo have our synths play in sync, we connect them over MIDI.\nBut when I started using Tidal,\nsetting up the MIDI clock was not so convenient and I was afraid of it crashing, which would stop the show for everyone.\nSo I started looking for a way to have a stable MIDI clock\nand connect it with Tidal.\nSoon thereafter, I learned about Link."),(0,i.kt)("p",null,'The purpose of Link is to "synchronize musical beat, tempo, phase ',"[...]",' across multiple applications running on one or more devices." Unlike traditional MIDI clock synchronization, which relies on a single device acting as the master clock and sending timing information to all connected devices, Link uses a peer-to-peer network protocol to allow all devices to communicate with each other and agree on a common tempo and beat phase. This allows for more accurate and stable synchronization between devices, even if the tempo changes or if devices are added or removed from the network. Additionally, Link provides a way to sync devices wirelessly, eliminating the need for physical connections between devices.'),(0,i.kt)("p",null,"My idea was to have some application listen to the MIDI clock and use Link to sync Tidal with that MIDI clock.\nI learned later that Link is not meant to be used that way,\nbut the idea got me started on integrating Tidal with Link..."),(0,i.kt)("h2",{id:"i-get-started"},"I get started"),(0,i.kt)("p",null,"November 2021 is the start of my journey for adding Link support to Tidal.\nI started discussing the path forward with Yaxu, Tidal's inventor, in two Github Issues (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/yaxu/hylia-haskell/issues/1"},"1"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tidalcycles/Tidal/issues/660"},"2"),").\nYaxu had already done some thinking about adding Link to Tidal and he had also done some exploration that I could learn from.\nHis positive responses motivated me and brought me confidence that this was a pursuit worth taking!"),(0,i.kt)("p",null,'One of the main challenges of integrating Link with Tidal was that Tidal is written in Haskell, while Link is a C++ library. I knew that C++ libraries can be exposed as C libraries, and Haskell can interact with C libraries through a mechanism called the "Foreign Function Interface" (FFI), but I had never done so before.\nNonetheless, I set out to create a basic Link integration in Haskell and I fairly quickly had something that compiled.\nIn the world of Haskell, this is often a huge success which means you can pack up - work\'s done!\nBut in this case, work was far from done...'),(0,i.kt)("h2",{id:"challenges"},"Challenges"),(0,i.kt)("p",null,"Some parts of the Link library was working, but when calling the crucial code ",(0,i.kt)("inlineCode",{parentName:"p"},"this->link.enable(true);"),", GHC (the Haskell compiler / interpreter) crashed."),(0,i.kt)("p",null,"Debugging internal GHC crashes is tricky for most people, so I made many twists and turns to find out what might be wrong.\nSeveral long nights were spent reinstalling Haskell and battling build system configuration.\nThe full details are documented in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tidalcycles/Tidal/issues/660"},"the issue for Link support in Tidal"),", but the short story is that I found out that could avoid the crash by including Link as a shared Library.\nThis workaround was not suitable for the final release of Link support, but it let me continue the work."),(0,i.kt)("p",null,"After making great progress on the Link integration, I became ready to start replacing the workaround.\n6 weeks into my ambitious project, I was ready to report an ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/20918"},"issue to the Haskell maintainers"),".\nI reported that my program worked when using ",(0,i.kt)("inlineCode",{parentName:"p"},"cabal v2-run")," but not ",(0,i.kt)("inlineCode",{parentName:"p"},"cabal v2-repl"),".\nSince Tidal uses GHCi (the REPL), this problem was crucial to resolve."),(0,i.kt)("p",null,"Several GHC maintainers pitched in, offering suggestions and trying to reproduce my issue.\nUnfortunately, I could reproduce the issue, but the GHC maintainers were not as successful so interest faded."),(0,i.kt)("p",null,"I went ahead and reproduced the issue several times, but only on Windows - not Linux, and even got a friend to reproduce it on their machine.\nHowever, this did not immediately rekindle the interest of the maintainers."),(0,i.kt)("p",null,"I started digging deeper to identify the root cause.\nFirst by using WinDbg, but the call stacks and multiple threads were too convoluted for me to digest.\nSo I resorted to print-debugging, working my way through the C++ code, adding printouts everywhere.\nSoon thereafter, I had my eureka moment!\nI isolated the issue to be caused by using C++ Exceptions!\nEven caught exceptions caused issues for GHCi, but not for the compiled executable."),(0,i.kt)("p",null,"I could now provide a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Zalastax/ghc-bug-20918"},"minimal example")," and, one day later, a Haskell maintainer replied with a ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/20918#note_414002"},"detailed analysis"),", which I quote here in full:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The RTS's Runtime linker doesn't support C++ exceptions on any platform in non-dynamic way. Historically we've never needed to as not many C++ code was being used.  It works on Linux because it defaults to dynamic way, which gets the system loader to handle the heavy lifting."),(0,i.kt)("p",{parentName:"blockquote"},"On Windows we don't handle .xdata and .pdata sections, so once you get an exception the OS unwinder asks us if we can handle the exception and we say no and move on and the crash occurs. You don't see GHC's panic message because the dynamic code is created outside of GHC's VEH region."),(0,i.kt)("blockquote",{parentName:"blockquote"},(0,i.kt)("p",{parentName:"blockquote"},"If I instead build a .dll and make my FFI calls towards that .dll, the code does not crash in GHCi")),(0,i.kt)("p",{parentName:"blockquote"},"Yes for the same reason as it works on Linux, the exception will be handled by the system unwinder."),(0,i.kt)("p",{parentName:"blockquote"},"Now supporting this on Windows these days is a lot easier than it used to be.  GHC Already has a native exception handling in place for itself in the VEH handlers. and we've dropped support for x86. x86_64 uses exception tables but gives us an easy way to extend the exception tables for dynamic code like JITed code.")),(0,i.kt)("p",null,"3 months later, the issue was fully fixed and ready to be included in GHC 9.4.2.\nThis let me finally remove the workaround, use Link directly instead of as a shared library,\nand integrate my work to the Tidal repository.\nThis bug in GHC is the reason Tidal 1.9 requires GHC 9.4.2 or later on Windows."),(0,i.kt)("p",null,"I'm very proud of my perseverence to resolve this issue.\nI started my attemps late November 2021 and merged the code to Tidal early July 2022."),(0,i.kt)("h2",{id:"link-and-tidal-integration-architecture-overview"},"Link and Tidal integration: Architecture Overview"),(0,i.kt)("p",null,"The integration of Link with Tidal posed several challenges but the end result was a success. In this section, we provide an overview of the architecture of the Link and Tidal integration and discuss the design choices made along the way. This information can serve as a guide for those who wish to create their own Link integration in different projects."),(0,i.kt)("h3",{id:"tidal-innards"},"Tidal Innards"),(0,i.kt)("p",null,"Let's start by exploring some Tidal Innards. For a more complete reference, please refer to ",(0,i.kt)("a",{parentName:"p",href:"https://tidalcycles.org/docs/innards/what_is_a_pattern"},"What is a pattern?"),"."),(0,i.kt)("p",null,"Some important concepts in Tidal innards are Arc, Part and Event:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"-- | A time arc (start and end)\ntype Arc = (Time, Time)\n\n-- Tidal often needs to represent a Part of an Arc.\n-- It does so with two arcs, the first representing the whole of the part,\n-- and the second the part itself.\n-- Often both arcs will be the same,\n-- which simply means that we have a whole that has a single part.\n--\n-- | The second arc (the part) should be equal to or fit inside the\n-- first one (the whole that it's a part of).\ntype Part = (Arc, Arc)\n\n-- | An event is a value that's active during a timespan\ntype Event a = (Part, a)\n")),(0,i.kt)("p",null,"Tidal processes musical patterns by querying for all Events within an Arc.\nThe Events returned by the query are distributed to targets such as SuperCollider.\nThese details remained unchanged when moving to Link as the base for the scheduler."),(0,i.kt)("h3",{id:"link-concepts"},"Link Concepts"),(0,i.kt)("p",null,"The Link API is responsible for converting between beats/cycles on a shared timeline and a clock that corresponds to when the sound should play from the speaker.\nThe concept is visualized in a timeline diagram below.\nTwo Link instances are shown.\nThe top and bottom of the diagram show how the two instances have their own beat counter.\nHowever, the beats have a shared phase - they align over bar or loop boundaries.\nI created the diagram below with alignment every 8 bars."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"link timeline diagram",src:n(863).Z,width:"736",height:"401"})),(0,i.kt)("p",null,"The API between Tempo.hs and Stream.hs hides how Link is called.\nThis helps separate concerns but could also enable alternative time keeping mechanisms.\nIt should not be too difficult to implement the API using the local system clock and memory to keep track of a local timeline.\nPlease reach out if you would like to create such an implementation!\nDoing so could open the door for adding back other synchronization mechanisms again :)"),(0,i.kt)("p",null,"The API between Tempo.hs and Stream.hs includes the following operations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"data LinkOperations = LinkOperations {\n  timeAtBeat    :: Link.Beat -> IO Link.Micros,\n  timeToCycles  :: Link.Micros -> IO P.Time,\n  getTempo      :: IO Link.BPM,\n  setTempo      :: Link.BPM -> Link.Micros -> IO (),\n  linkToOscTime :: Link.Micros -> O.Time,\n  beatToCycles  :: CDouble -> CDouble,\n  cyclesToBeat  :: CDouble -> CDouble\n}\n")),(0,i.kt)("h4",{id:"calling-the-link-api-from-haskell"},"Calling the Link API from Haskell"),(0,i.kt)("p",null,"As mentioned in ",(0,i.kt)("a",{parentName:"p",href:"#Troubles"},"Troubles"),', Link is a C++ library and the Haskell integration is done using the "Foreign Function Interface" (FFI).\nHaskell has some support for integrating directly with C++,\nbut it seemed too difficult to use for my taste.'),(0,i.kt)("p",null,"Fortunately, while I was working on my implementation,\nLink released a C-wrapper of their library.\nIntegrating with C-libraries from Haskell is fairly easy,\nand mostly comes down to setting up the compiler correctly and defining the C-functions in a .hsc-file."),(0,i.kt)("p",null,"Conversion is straight forward:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Haskell"},'-- Haskell\ndata AbletonLinkImpl\ndata SessionStateImpl\n\nnewtype AbletonLink = AbletonLink (Ptr AbletonLinkImpl)\nnewtype SessionState = SessionState (Ptr SessionStateImpl)\n\nforeign import ccall "abl_link.h abl_link_commit_app_session_state"\n  commitAppSessionState :: AbletonLink -> SessionState -> IO ()\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-C"},"// C\n\n typedef struct abl_link\n  {\n    void *impl;\n  } abl_link;\n\n  typedef struct abl_link_session_state\n  {\n    void *impl;\n  } abl_link_session_state;\n\nvoid abl_link_commit_app_session_state(\n    abl_link link, abl_link_session_state session_state);\n")),(0,i.kt)("h3",{id:"ticks-and-processing-ahead"},"Ticks and Processing Ahead"),(0,i.kt)("p",null,"Tidal needs to process events a few hundred milliseconds early so that the event can reach the sound engine/synthesizer in time.\nOtherwise, the event would play late from the speaker, and we would not be synchronized with others in the same Link session.\nThe processing ahead is configured via ",(0,i.kt)("inlineCode",{parentName:"p"},"cProcessAhead"),"."),(0,i.kt)("p",null,'The scheduler is based on "logical time" that uses a tick based system.\nThis means that the implementation keeps track of the starting time and the length of each "tick" in order to step time forward in equal chunks.\nTo turn the tick number into a "logical time", the following formula is used:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"logicalTime startTime ticks' = startTime + ticks' * frameTimespan\n")),(0,i.kt)("p",null,"Working with logical time / ticks is a common approach to avoid time drifts which I kept from the original scheduler.\nI'm not sure how much difference it still makes now that Link does the heavy lifting,\nbut it felt safest to keep it."),(0,i.kt)("h3",{id:"putting-it-together"},"Putting it together"),(0,i.kt)("p",null,"With the different components explained, I can now explain the whole:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Tidal processes events ahead of time by querying for events within an Arc that has not happened yet (based on the tick system)."),(0,i.kt)("li",{parentName:"ul"},"Processing events ahead of time is common to all Link based systems since it's the only way to not play the sound too late due to the Link API being based on when the sound should play from the speaker."),(0,i.kt)("li",{parentName:"ul"},"The translation from cycles in Tidal to a timestamp is performed by the Link API.")),(0,i.kt)("p",null,"The picture below shows the relation between Link, the logical clock, and the current time.\nThe current time is greater than the logical time of Tick 24,\nwhich means that we should be processing all Events that happen between the Arc ",(0,i.kt)("inlineCode",{parentName:"p"},"(Tick 24,  Tick 25)"),".\nWe query for all Events within this Arc and convert the start and end cycle of each Event to a clock time by using the Link API.\nAs mentioned earlier, the events that we currently query for should all happen in the future.\nThis is why the mapping from Logical clock to Link instance time is a diagonal arrow that goes forward in time."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"logical clock",src:n(8218).Z,width:"824",height:"514"})),(0,i.kt)("h3",{id:"a-note-about-multithreading"},"A note about multithreading"),(0,i.kt)("p",null,"The scheduler runs in a separate thread, so Tidal is multithreaded.\nThis follows the approach used by the previous scheduler and ensures that the GHCi REPL keeps being responsive."),(0,i.kt)("p",null,"The original design used several MVars to copy data between processes.\nMVars are a concept from concurrent Haskell.\nThey act as synchronising variables and are used for communication between concurrent threads."),(0,i.kt)("p",null,"However, the design based on several MVars made the code difficult to follow and hard to verify for correctness.\nIn the new design, we communicate between threads using a list of actions, similar to dispatching Actions to Redux in JavaScript or calling an actor in Erlang.\nThis puts all the tricky logic that deals with the internal state in a single place.\nFollowing this approach makes the code much more easy to reason about and is why I like Erlang so much ;)"),(0,i.kt)("p",null,"The list of actions is communicated using an ",(0,i.kt)("inlineCode",{parentName:"p"},"MVar [TempoAction]"),".\nThe definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"TempoAction")," is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"data TempoAction =\n  SetCycle P.Time\n  | SingleTick P.ControlSignal\n  | SetNudge Double\n  | StreamReplace ID P.ControlSignal\n  | Transition Bool TransitionMapper ID P.ControlSignal\n")),(0,i.kt)("p",null,"Each action can thus be handled in sequence, making the logic easy to reason about."),(0,i.kt)("h2",{id:"final-words"},"Final words"),(0,i.kt)("p",null,"Contributing to Tidal was (and continues to be) a very fun experience!\nThe community is very nice and supportive and I enjoy working in the codebase."),(0,i.kt)("p",null,"It was surprising to see that I appear to be the first person to integrate between Haskell and C++ on Windows.\nAt least I am the first to report an error instead of giving up.\nI mean, the error I stumbled upon would have been found in most efforts to use C++ from Haskell because exceptions are very common in C++."),(0,i.kt)("p",null,"Once I could avoid the bugs in GHC, reworking the Tidal internals was quite straight forward.\nEven though I ripped most of the scheduler apart, the Haskell type system guided me through the refactoring.\nThe next goal was always visible and I had direction for what next step to take."),(0,i.kt)("p",null,"Finally, I want to thank my girlfriend Moa for supporting me through this project and for listening to me explaining my ups and downs.\nThe details must have been inpenetrable to understand,\nbut she still listened and shared my joy or despair.\nFor that, and incountable other things: Moa, I love you!"),(0,i.kt)("p",null,"To the rest of the Tidal community, you're awesome too, and I'm happy to be a part of your world!"),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/tidalcycles/Tidal/issues/660"},"GitHub Issue - Link support")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/20918"},"GHC Issue - Sudden exit in GHCi for FFI code - works when run as executable")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"http://ableton.github.io/link/"},"Link documentation")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://tidalcycles.org/docs/innards/what_is_a_pattern"},"What is a pattern?"))))}c.isMDXComponent=!0},863:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/link_timeline-eaca5be07783c6ce6c68b4117f37e64e.png"},8218:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/logical_clock-39fdcee171044a130d3ba7633ce13614.png"}}]);